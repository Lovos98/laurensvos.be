<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle UML Generator</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0a0a;
      overflow: hidden;
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      display: flex;
      height: 100vh;
    }

    /* Main layout */
    #renderer-container {
      flex: 1;
      position: relative;
      height: 100%;
      min-height: 100vh;
      overflow: hidden;
    }
    canvas { display: block; }
    #text-canvas {
      position: absolute;
      top: -9999px;
      left: -9999px;
    }

    /* Sidebar */
    #sidebar {
      width: 320px;
      height: 100vh;
      background: #0f0f0f;
      border-left: 1px solid #d4a855;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Tabs */
    #tabs {
      display: flex;
      background: #141414;
      border-bottom: 1px solid #d4a855;
      flex-shrink: 0;
    }
    .tab {
      padding: 12px 16px;
      color: #888;
      cursor: pointer;
      font-size: 11px;
      border-right: 1px solid #d4a85533;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 1px;
      flex: 1;
      text-align: center;
    }
    .tab:hover {
      color: #d4a855;
      background: rgba(212, 168, 85, 0.1);
    }
    .tab.active {
      color: #d4a855;
      background: rgba(212, 168, 85, 0.15);
      border-bottom: 2px solid #d4a855;
      margin-bottom: -1px;
    }

    #controls {
      flex: 1;
      padding: 15px;
      color: #d4a855;
      font-size: 11px;
      overflow-y: auto;
    }
    #controls h3 {
      margin-bottom: 10px;
      font-size: 13px;
      border-bottom: 1px solid #d4a85544;
      padding-bottom: 8px;
    }
    #controls h4 {
      margin: 15px 0 8px 0;
      font-size: 11px;
      color: #a3a3a3;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .control-group {
      margin-bottom: 10px;
    }
    .control-group label {
      display: block;
      margin-bottom: 3px;
      color: #888;
      font-size: 10px;
    }
    .control-group input[type="range"] {
      width: 100%;
      accent-color: #d4a855;
    }
    .control-group input[type="text"],
    .control-group input[type="number"] {
      width: 100%;
      background: #1a1a1a;
      border: 1px solid #d4a855;
      color: #d4a855;
      padding: 6px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-family: inherit;
    }
    .control-group .value {
      float: right;
      color: #d4a855;
    }
    .control-group select {
      width: 100%;
      background: #1a1a1a;
      border: 1px solid #d4a855;
      color: #d4a855;
      padding: 4px;
      border-radius: 4px;
      font-size: 11px;
    }
    button {
      background: #d4a855;
      color: #0a0a0a;
      border: none;
      padding: 8px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      margin-top: 8px;
      font-size: 11px;
    }
    button:hover {
      background: #e5b966;
    }
    .button-row {
      display: flex;
      gap: 8px;
    }
    .button-row button {
      flex: 1;
    }
    .icon-button {
      width: auto;
      padding: 8px 12px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .icon-button svg {
      width: 14px;
      height: 14px;
    }

    /* Pattern controls */
    .pattern-controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .pattern-controls select {
      flex: 1;
    }
    .pattern-buttons {
      display: flex;
      gap: 4px;
    }
    .small-btn {
      width: 24px;
      height: 24px;
      padding: 0;
      margin: 0;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      background: #333;
      color: #d4a855;
      border: 1px solid #d4a855;
    }
    .small-btn:hover {
      background: #d4a855;
      color: #0a0a0a;
    }
    .small-btn.danger {
      border-color: #c44;
      color: #c44;
    }
    .small-btn.danger:hover {
      background: #c44;
      color: white;
    }
    .regen-btn {
      width: 100%;
      padding: 10px 15px;
      margin-bottom: 15px;
      font-size: 12px;
      font-weight: bold;
      border-radius: 4px;
      background: #333;
      color: #d4a855;
      border: 1px solid #d4a855;
      cursor: pointer;
      transition: all 0.2s;
    }
    .regen-btn:hover {
      background: #d4a855;
      color: #0a0a0a;
    }

    /* Layout variation buttons */
    .layout-buttons {
      display: flex;
      gap: 8px;
    }
    .layout-btn {
      width: 36px;
      height: 28px;
      padding: 0;
      margin: 0;
      background: #1a1a1a;
      border: 1px solid #333;
      color: #888;
      font-size: 12px;
      font-weight: bold;
      border-radius: 4px;
      cursor: pointer;
    }
    .layout-btn:hover {
      border-color: #d4a855;
      color: #d4a855;
    }
    .layout-btn.active {
      background: #d4a855;
      border-color: #d4a855;
      color: #0a0a0a;
    }

    /* Modal dialog */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }
    .modal-overlay.visible {
      display: flex;
    }
    .modal {
      background: #1a1a1a;
      border: 1px solid #d4a855;
      border-radius: 8px;
      padding: 20px;
      min-width: 300px;
      max-width: 400px;
    }
    .modal h3 {
      margin: 0 0 15px 0;
      color: #d4a855;
    }
    .modal p {
      margin: 0 0 15px 0;
      color: #888;
    }
    .modal input[type="text"] {
      width: 100%;
      background: #0a0a0a;
      border: 1px solid #333;
      color: #d4a855;
      padding: 8px;
      border-radius: 4px;
      margin-bottom: 15px;
      box-sizing: border-box;
    }
    .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
    .modal-buttons button {
      margin: 0;
      min-width: 80px;
    }
    .modal-buttons button.cancel {
      background: #333;
      color: #888;
    }
    .modal-buttons button.cancel:hover {
      background: #444;
      color: #aaa;
    }
    .modal-buttons button.danger {
      background: #c44;
      color: white;
    }
    .modal-buttons button.danger:hover {
      background: #d55;
    }

    #noise-preview-container {
      margin-top: 15px;
      border-top: 1px solid #d4a85544;
      padding-top: 10px;
    }
    #noise-preview {
      width: 100%;
      height: 80px;
      border: 1px solid #d4a855;
      border-radius: 4px;
      image-rendering: pixelated;
    }
    .preview-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      color: #888;
      font-size: 10px;
    }

    #controls::-webkit-scrollbar {
      width: 6px;
    }
    #controls::-webkit-scrollbar-track {
      background: transparent;
    }
    #controls::-webkit-scrollbar-thumb {
      background: #d4a85544;
      border-radius: 3px;
    }

    /* Debug toggle */
    .toggle-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
    }
    .toggle-row input[type="checkbox"] {
      accent-color: #d4a855;
      width: 16px;
      height: 16px;
    }
    .toggle-row label {
      color: #888;
      font-size: 11px;
    }

    /* Tab content areas */
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }

    /* Pattern preview */
    .pattern-preview {
      margin-top: 15px;
      padding: 10px;
      border: 1px solid #d4a85544;
      border-radius: 4px;
      background: rgba(212, 168, 85, 0.05);
    }
    .pattern-preview .preview-label {
      color: #d4a855;
      font-size: 11px;
      font-weight: bold;
      margin-bottom: 5px;
    }

    /* Save notification */
    .save-notification {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #d4a855;
      color: #0a0a0a;
      padding: 10px 20px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
      z-index: 2000;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .save-notification.show {
      opacity: 1;
    }

    /* SVG UML Editor container */
    #uml-editor {
      width: 100%;
      height: 100%;
      background: #0a0a0a;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      overflow: hidden;
      cursor: grab;
    }
    #uml-editor.panning {
      cursor: grabbing;
    }
    #uml-svg {
      width: 100%;
      height: 100%;
    }

    /* Node position controls */
    #node-position-controls {
      display: none;
      margin-top: 15px;
      padding: 10px;
      border: 1px solid #d4a85544;
      border-radius: 4px;
      background: rgba(212, 168, 85, 0.05);
    }
    #node-position-controls.visible {
      display: block;
    }
    #node-position-controls h4 {
      margin: 0 0 10px 0;
      color: #d4a855;
    }
    .position-row {
      display: flex;
      gap: 10px;
      margin-bottom: 8px;
    }
    .position-row label {
      width: 20px;
      color: #888;
      font-size: 11px;
    }
    .position-row input {
      flex: 1;
      background: #1a1a1a;
      border: 1px solid #d4a855;
      color: #d4a855;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-family: inherit;
    }

    /* Three.js canvas container */
    #three-canvas {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }
    #film-overlay {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 2;
      pointer-events: none;
      display: none;
    }
    [data-current-tab="total-preview"] #film-overlay {
      display: block;
    }

    /* Show/hide based on tab */
    [data-current-tab="uml-generator"] #uml-editor {
      display: block;
    }
    [data-current-tab="uml-generator"] #three-canvas {
      display: none;
    }
    [data-current-tab="noise-generator"] #uml-editor,
    [data-current-tab="total-preview"] #uml-editor {
      display: none;
    }
    [data-current-tab="noise-generator"] #three-canvas,
    [data-current-tab="total-preview"] #three-canvas {
      display: block;
    }

    /* SVG UML Node styling */
    .uml-node-group {
      cursor: move;
    }
    .uml-node-group.selected .node-border {
      stroke: #e5b966;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px rgba(212, 168, 85, 0.5));
    }
    .uml-node-group:hover .node-border {
      stroke: #e5b966;
    }
    .node-bg {
      fill: #141414;
    }
    .node-border {
      fill: none;
      stroke: #d4a855;
      stroke-width: 2;
    }
    .node-header-bg {
      fill: rgba(212, 168, 85, 0.15);
    }
    .node-header-bg.interface {
      fill: rgba(212, 168, 85, 0.25);
    }
    .node-divider {
      stroke: #d4a855;
      stroke-width: 1;
      opacity: 0.5;
    }
    .node-stereotype {
      fill: #d4a855;
      font-size: 9px;
      font-style: italic;
      opacity: 0.7;
    }
    .node-name {
      fill: #d4a855;
      font-size: 13px;
      font-weight: bold;
    }
    .node-member {
      fill: #d4a855;
      font-size: 10px;
      opacity: 0.8;
    }

    /* Connection lines */
    .connection-line {
      stroke: #d4a855;
      stroke-width: 2;
      fill: none;
    }
    .connection-line.implements,
    .connection-line.dependency {
      stroke-dasharray: 8, 4;
    }
    .connection-line.extends,
    .connection-line.association,
    .connection-line.aggregation,
    .connection-line.composition {
      stroke-dasharray: none;
    }
    .connection-arrow {
      fill: none;
      stroke: #d4a855;
      stroke-width: 2;
    }
    .connection-arrow.implements,
    .connection-arrow.extends {
      fill: none;
    }
    .connection-arrow.association,
    .connection-arrow.dependency {
      fill: none;
    }
    .connection-arrow.aggregation {
      fill: #1a1a2e;
      stroke: #d4a855;
    }
    .connection-arrow.composition {
      fill: #d4a855;
      stroke: #d4a855;
    }
    .connection-label {
      fill: #d4a855;
      font-size: 11px;
      font-style: italic;
    }

    /* Hide renderer buttons based on tab */
    .uml-only {
      display: none;
    }
    [data-current-tab="uml-generator"] .uml-only {
      display: flex;
    }
  </style>
</head>
<body>
  <canvas id="text-canvas"></canvas>
  <div id="saveNotification" class="save-notification">Settings saved!</div>

  <!-- Modal: New Pattern -->
  <div id="newPatternModal" class="modal-overlay">
    <div class="modal">
      <h3>New Pattern</h3>
      <p>Enter a name for the new pattern:</p>
      <input type="text" id="newPatternName" placeholder="My Pattern">
      <div class="modal-buttons">
        <button class="cancel" onclick="closeModal('newPatternModal')">Cancel</button>
        <button onclick="createNewPattern()">Create</button>
      </div>
    </div>
  </div>

  <!-- Modal: Delete Pattern -->
  <div id="deletePatternModal" class="modal-overlay">
    <div class="modal">
      <h3>Delete Pattern</h3>
      <p>Are you sure you want to delete "<span id="deletePatternName"></span>"?</p>
      <p style="color: #c44; font-size: 11px;">This will delete the pattern file permanently.</p>
      <div class="modal-buttons">
        <button class="cancel" onclick="closeModal('deletePatternModal')">Cancel</button>
        <button class="danger" onclick="confirmDeletePattern()">Delete</button>
      </div>
    </div>
  </div>

  <!-- Renderer container (left side) -->
  <div id="renderer-container" data-current-tab="uml-generator">
    <!-- SVG UML Editor for UML tab -->
    <div id="uml-editor">
      <svg id="uml-svg" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
            <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#1a1a1a" stroke-width="0.5"/>
          </pattern>
        </defs>
        <rect width="100%" height="100%" fill="url(#grid)"/>
        <g id="connections-layer"></g>
        <g id="nodes-layer"></g>
      </svg>
    </div>
    <!-- Three.js canvas wrapper for Noise/Preview tabs -->
    <div id="three-canvas"></div>
    <!-- Film grain overlay -->
    <canvas id="film-overlay"></canvas>
  </div>

  <!-- Sidebar (right side) -->
  <div id="sidebar">
    <div id="tabs">
      <div class="tab active" data-tab="uml-generator">UML</div>
      <div class="tab" data-tab="noise-generator">Noise</div>
      <div class="tab" data-tab="total-preview">Preview</div>
    </div>

    <div id="controls">
    <!-- UML Generator Tab -->
    <div class="tab-content active" id="tab-uml-generator">
      <h3>UML Generator</h3>

      <h4>Design Pattern</h4>
      <div class="control-group">
        <label>Pattern</label>
        <div class="pattern-controls">
          <select id="patternSelect">
            <!-- Populated from patterns-index.json -->
          </select>
          <div class="pattern-buttons">
            <button id="newPatternBtn" class="small-btn" title="New Pattern">+</button>
            <button id="deletePatternBtn" class="small-btn danger" title="Delete Pattern">×</button>
          </div>
        </div>
      </div>
      <div class="control-group">
        <label>Layout Variation</label>
        <div class="layout-buttons">
          <button id="layout-1" class="layout-btn active" data-layout="1">1</button>
          <button id="layout-2" class="layout-btn" data-layout="2">2</button>
          <button id="layout-3" class="layout-btn" data-layout="3">3</button>
        </div>
      </div>

      <div class="pattern-preview" id="patternPreview">
        <div class="preview-label">Pattern Structure</div>
        <div id="patternDescription" style="color: #888; font-size: 10px; margin-top: 5px;"></div>
      </div>

      <div id="node-position-controls">
        <h4>Selected Node Position</h4>
        <div id="selectedNodeName" style="color: #d4a855; margin-bottom: 10px; font-weight: bold;"></div>
        <div class="position-row">
          <label>X:</label>
          <input type="number" id="nodePositionX" step="1" min="0">
        </div>
        <div class="position-row">
          <label>Y:</label>
          <input type="number" id="nodePositionY" step="1" min="0">
        </div>
      </div>

      <button id="generateUML" style="width: 100%;">Generate UML</button>
    </div>

    <!-- Noise Generator Tab -->
    <div class="tab-content" id="tab-noise-generator">
      <h3>Noise Generator</h3>

      <h4>Particles</h4>
      <div class="control-group">
        <label>Density (spacing) <span class="value" id="densityVal">0.5</span></label>
        <input type="range" id="density" min="0.1" max="2" step="0.1" value="0.5">
      </div>

      <div class="control-group">
        <label>Particle Size <span class="value" id="particleSizeVal">1</span></label>
        <input type="range" id="particleSize" min="0.5" max="8" step="0.25" value="1">
      </div>

      <div class="control-group">
        <label>Particle Opacity <span class="value" id="particleOpacityVal">0.5</span></label>
        <input type="range" id="particleOpacity" min="0.1" max="1" step="0.05" value="0.5">
      </div>

      <h4>Noise Type</h4>
      <div class="control-group">
        <label>Base Noise</label>
        <select id="noiseType">
          <option value="smooth">Smooth Perlin</option>
          <option value="square" selected>Square/Blocky Perlin</option>
          <option value="ridged">Ridged</option>
          <option value="cellular">Cellular</option>
        </select>
      </div>

      <h4>Noise Shape</h4>
      <div class="control-group">
        <label>Noise Scale <span class="value" id="noiseScaleVal">0.05</span></label>
        <input type="range" id="noiseScale" min="0.001" max="0.1" step="0.001" value="0.05">
      </div>

      <div class="control-group">
        <label>Block Size <span class="value" id="blockSizeVal">5</span></label>
        <input type="range" id="blockSize" min="1" max="200" step="1" value="5">
      </div>

      <div class="control-group">
        <label>Edge Sharpness <span class="value" id="sharpnessVal">5</span></label>
        <input type="range" id="sharpness" min="0.5" max="8" step="0.25" value="5">
      </div>

      <div class="control-group">
        <label>Contrast <span class="value" id="contrastVal">1.5</span></label>
        <input type="range" id="contrast" min="0.5" max="4" step="0.1" value="1.5">
      </div>

      <h4>Turbulence (Octaves)</h4>
      <div class="control-group">
        <label>Octaves <span class="value" id="turbulenceVal">8</span></label>
        <input type="range" id="turbulence" min="1" max="8" step="1" value="8">
      </div>

      <div class="control-group">
        <label>Lacunarity (freq×) <span class="value" id="lacunarityVal">1</span></label>
        <input type="range" id="lacunarity" min="1" max="4" step="0.1" value="1">
      </div>

      <div class="control-group">
        <label>Persistence (amp×) <span class="value" id="persistenceVal">0.5</span></label>
        <input type="range" id="persistence" min="0.1" max="0.9" step="0.05" value="0.5">
      </div>

      <h4>Animation</h4>
      <div class="control-group">
        <label>Noise Speed <span class="value" id="noiseSpeedVal">1</span></label>
        <input type="range" id="noiseSpeed" min="0" max="2" step="0.05" value="1">
      </div>

      <h4>Displacement</h4>
      <div class="control-group">
        <label>X/Y Amount <span class="value" id="displacementXYVal">8</span></label>
        <input type="range" id="displacementXY" min="0" max="50" step="1" value="8">
      </div>

      <div class="control-group">
        <label>Z Amount <span class="value" id="displacementZVal">15</span></label>
        <input type="range" id="displacementZ" min="0" max="50" step="1" value="15">
      </div>

      <div class="button-row">
        <button id="regenerateNoise">Apply to Preview</button>
        <button id="saveNoiseSettings" class="icon-button">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z"/>
            <polyline points="17,21 17,13 7,13 7,21"/>
            <polyline points="7,3 7,8 15,8"/>
          </svg>
          Save
        </button>
      </div>

      <div id="noise-preview-container">
        <div class="preview-label">
          <span>Noise Preview</span>
          <span id="previewFps">0 fps</span>
        </div>
        <canvas id="noise-preview"></canvas>
      </div>
    </div>

    <!-- Total Preview Tab -->
    <div class="tab-content" id="tab-total-preview">
      <h3>Cinematic Preview</h3>

      <button id="regeneratePreview" class="regen-btn">Regenerate Procedural UML</button>

      <h4>Camera Path (Lissajous)</h4>
      <div class="control-group">
        <label>Path Speed <span class="value" id="cameraSpeedVal">0.3</span></label>
        <input type="range" id="cameraSpeed" min="0" max="1" step="0.01" value="0.3">
      </div>
      <div class="control-group">
        <label>X Amplitude <span class="value" id="cameraAmpXVal">200</span></label>
        <input type="range" id="cameraAmpX" min="0" max="500" step="10" value="200">
      </div>
      <div class="control-group">
        <label>Y Amplitude <span class="value" id="cameraAmpYVal">100</span></label>
        <input type="range" id="cameraAmpY" min="0" max="500" step="10" value="100">
      </div>
      <div class="control-group">
        <label>Z Amplitude <span class="value" id="cameraAmpZVal">150</span></label>
        <input type="range" id="cameraAmpZ" min="0" max="500" step="10" value="150">
      </div>
      <div class="control-group">
        <label>X Frequency <span class="value" id="cameraFreqXVal">1</span></label>
        <input type="range" id="cameraFreqX" min="1" max="5" step="1" value="1">
      </div>
      <div class="control-group">
        <label>Y Frequency <span class="value" id="cameraFreqYVal">2</span></label>
        <input type="range" id="cameraFreqY" min="1" max="5" step="1" value="2">
      </div>
      <div class="control-group">
        <label>Z Frequency <span class="value" id="cameraFreqZVal">3</span></label>
        <input type="range" id="cameraFreqZ" min="1" max="5" step="1" value="3">
      </div>

      <h4>Camera Lens</h4>
      <div class="control-group">
        <label>Base Distance <span class="value" id="cameraDistanceVal">800</span></label>
        <input type="range" id="cameraDistance" min="200" max="2000" step="50" value="800">
      </div>
      <div class="control-group">
        <label>Field of View <span class="value" id="cameraFovVal">50</span></label>
        <input type="range" id="cameraFov" min="20" max="120" step="5" value="50">
      </div>
      <div class="control-group">
        <label>Tilt Angle <span class="value" id="cameraTiltVal">25</span></label>
        <input type="range" id="cameraTilt" min="0" max="60" step="5" value="25">
      </div>

      <h4>Film Grain</h4>
      <div class="control-group">
        <label>Intensity <span class="value" id="filmGrainVal">0.15</span></label>
        <input type="range" id="filmGrain" min="0" max="0.5" step="0.01" value="0.15">
      </div>
      <div class="control-group">
        <label>Roughness <span class="value" id="grainRoughnessVal">1</span></label>
        <input type="range" id="grainRoughness" min="0.5" max="3" step="0.1" value="1">
      </div>
      <div class="control-group">
        <label>Size <span class="value" id="grainSizeVal">1</span></label>
        <input type="range" id="grainSize" min="0.5" max="4" step="0.5" value="1">
      </div>

      <h4>Glitch</h4>
      <div class="control-group">
        <label>Intensity <span class="value" id="glitchIntensityVal">1.5</span></label>
        <input type="range" id="glitchIntensity" min="0" max="3" step="0.1" value="1.5">
      </div>
      <div class="control-group">
        <label>Frequency <span class="value" id="glitchChanceVal">0.35</span></label>
        <input type="range" id="glitchChance" min="0" max="0.6" step="0.02" value="0.35">
      </div>
      <div class="control-group">
        <label>Zone Size <span class="value" id="glitchMaskScaleVal">0.008</span></label>
        <input type="range" id="glitchMaskScale" min="0.002" max="0.03" step="0.001" value="0.008">
      </div>
      <div class="control-group">
        <label>Speed <span class="value" id="glitchSpeedVal">2</span></label>
        <input type="range" id="glitchSpeed" min="0.5" max="5" step="0.5" value="2">
      </div>
      <div class="control-group">
        <label>RGB Split <span class="value" id="rgbSplitVal">1</span></label>
        <input type="range" id="rgbSplit" min="0" max="3" step="0.1" value="1">
      </div>

      <h4>Post Effects</h4>
      <div class="control-group">
        <label>Vignette <span class="value" id="vignetteVal">0.4</span></label>
        <input type="range" id="vignette" min="0" max="1" step="0.05" value="0.4">
      </div>

      <div class="toggle-row" style="margin-top: 16px;">
        <input type="checkbox" id="cinematicMode" checked>
        <label for="cinematicMode">Cinematic Mode</label>
      </div>

      <div class="button-row">
        <button id="saveAllSettings" class="icon-button">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z"/>
            <polyline points="17,21 17,13 7,13 7,21"/>
            <polyline points="7,3 7,8 15,8"/>
          </svg>
          Save All
        </button>
      </div>
    </div>
  </div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // State management
    let currentTab = 'uml-generator';

    // Hardcoded fallback defaults (used if values.json fails to load)
    const hardcodedDefaults = {
      // Noise settings
      noiseType: 'square',
      density: 0.5,
      noiseScale: 0.05,
      noiseSpeed: 1,
      blockSize: 5,
      turbulence: 8,
      lacunarity: 1,
      persistence: 0.5,
      sharpness: 5,
      contrast: 1.5,
      particleSize: 1,
      particleOpacity: 0.5,
      displacementXY: 8,
      displacementZ: 15,
      // Camera path settings (Lissajous)
      cameraSpeed: 0.3,
      cameraAmpX: 200,
      cameraAmpY: 100,
      cameraAmpZ: 150,
      cameraFreqX: 1,
      cameraFreqY: 2,
      cameraFreqZ: 3,
      // Camera lens settings
      cameraDistance: 800,
      cameraFov: 50,
      cameraTilt: 25,
      cinematicMode: true,
      // Film grain
      filmGrain: 0.15,
      grainRoughness: 1.0,
      grainSize: 1.0,
      // Glitch effect (random per-node)
      glitchIntensity: 1.5,
      glitchChance: 0.35,
      glitchMaskScale: 0.008,
      glitchSpeed: 2.0,
      rgbSplit: 1.0,
      // Post effects
      vignette: 0.4,
      // Layout settings
      nodeSpacing: 450,
      nodeWidth: 300,
      nodeHeight: 220,
      // Pattern settings
      selectedPattern: 'factory'
    };

    // Will be populated from values.json
    let params = { ...hardcodedDefaults };

    // Load settings from values.json via API
    async function loadSettingsFromFile() {
      try {
        const response = await fetch('/api/values');
        if (response.ok) {
          const loaded = await response.json();
          params = { ...hardcodedDefaults, ...loaded };
          console.log('Loaded settings from values.json');
          return true;
        }
      } catch (e) {
        console.warn('Failed to load values.json, using defaults:', e);
      }
      return false;
    }

    // Save settings to values.json via API
    async function saveSettingsToFile() {
      try {
        const response = await fetch('/api/values', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(params, null, 2)
        });
        if (response.ok) {
          // Also save comprehensive global config
          await saveGlobalConfig();
          showNotification('Settings saved!');
          return true;
        }
      } catch (e) {
        console.warn('Failed to save settings:', e);
      }
      return false;
    }

    // Save comprehensive global configuration for website dashboard
    async function saveGlobalConfig() {
      // Safety check - don't save if not fully initialized
      if (typeof umlNodes === 'undefined' || typeof currentLayout === 'undefined') {
        return;
      }

      const patternId = params.selectedPattern || 'factory';
      const pattern = (typeof customPatterns !== 'undefined' && customPatterns[patternId]) ||
                      (typeof patternDefinitions !== 'undefined' && patternDefinitions[patternId]) ||
                      null;

      const globalConfig = {
        // Metadata
        version: '1.0',
        lastUpdated: new Date().toISOString(),

        // Current pattern data
        pattern: {
          id: patternId,
          name: pattern?.name || patternId,
          description: pattern?.description || '',
          nodes: umlNodes ? JSON.parse(JSON.stringify(umlNodes)) : [],
          connections: pattern?.connections || [],
          currentLayout: currentLayout || '1'
        },

        // Noise settings
        noise: {
          type: params.noiseType,
          scale: params.noiseScale,
          speed: params.noiseSpeed,
          blockSize: params.blockSize,
          turbulence: params.turbulence,
          lacunarity: params.lacunarity,
          persistence: params.persistence,
          sharpness: params.sharpness,
          contrast: params.contrast
        },

        // Particle settings
        particles: {
          density: params.density,
          size: params.particleSize,
          opacity: params.particleOpacity,
          displacementXY: params.displacementXY,
          displacementZ: params.displacementZ
        },

        // Global noise activation
        activation: {
          globalNoiseScale: params.globalNoiseScale,
          globalNoiseSpeed: params.globalNoiseSpeed
        },

        // Camera path (Lissajous)
        camera: {
          cinematicMode: params.cinematicMode,
          speed: params.cameraSpeed,
          amplitude: {
            x: params.cameraAmpX,
            y: params.cameraAmpY,
            z: params.cameraAmpZ
          },
          frequency: {
            x: params.cameraFreqX,
            y: params.cameraFreqY,
            z: params.cameraFreqZ
          },
          distance: params.cameraDistance,
          fov: params.cameraFov,
          tilt: params.cameraTilt
        },

        // Film effects
        filmEffects: {
          grain: {
            intensity: params.filmGrain,
            roughness: params.grainRoughness,
            size: params.grainSize
          },
          glitch: {
            intensity: params.glitchIntensity,
            frequency: params.glitchChance,
            zoneSize: params.glitchMaskScale,
            speed: params.glitchSpeed,
            rgbSplit: params.rgbSplit
          },
          vignette: params.vignette
        }
      };

      try {
        await fetch('/api/global-config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(globalConfig, null, 2)
        });
      } catch (e) {
        console.warn('Failed to save global config:', e);
      }
    }

    function showNotification(message, duration = 3000) {
      const notification = document.getElementById('saveNotification');
      notification.textContent = message;
      notification.classList.add('show');
      setTimeout(() => notification.classList.remove('show'), duration);
    }

    // Debounced auto-save for settings
    let autoSaveTimeout = null;
    let globalConfigTimeout = null;
    let isInitialized = false;
    async function autoSave() {
      // Don't auto-save during initialization
      if (!isInitialized) return;

      if (autoSaveTimeout) clearTimeout(autoSaveTimeout);

      autoSaveTimeout = setTimeout(async () => {
        try {
          await fetch('/api/values', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(params)
          });
        } catch (e) {
          console.warn('Auto-save failed:', e);
        }
      }, 500);

      // Also save global config with longer debounce
      if (globalConfigTimeout) clearTimeout(globalConfigTimeout);
      globalConfigTimeout = setTimeout(() => {
        saveGlobalConfig();
      }, 2000);
    }

    // Debounced auto-save for custom patterns
    let patternAutoSaveTimeout = null;
    async function autoSavePattern() {
      const patternId = params.selectedPattern;
      if (!patternId || !customPatterns[patternId]) return;

      if (patternAutoSaveTimeout) clearTimeout(patternAutoSaveTimeout);

      patternAutoSaveTimeout = setTimeout(async () => {
        // Update pattern data with current nodes
        customPatterns[patternId].nodes = JSON.parse(JSON.stringify(umlNodes));

        // Save current layout positions
        if (!customPatterns[patternId].layouts) {
          customPatterns[patternId].layouts = {};
        }
        customPatterns[patternId].layouts[currentLayout] = umlNodes.map(n => ({
          id: n.id,
          x: n.x,
          y: n.y
        }));

        // Save via API
        try {
          const response = await fetch(`/api/pattern/${patternId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(customPatterns[patternId], null, 2)
          });
          if (response.ok) {
            showNotification('Pattern saved', 1000);
          }
        } catch (e) {
          console.warn('Pattern auto-save failed:', e);
        }
      }, 500);
    }

    // Scene setup
    const rendererContainer = document.getElementById('renderer-container');
    const threeCanvas = document.getElementById('three-canvas');
    const sidebarWidth = 320;
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, (window.innerWidth - sidebarWidth) / window.innerHeight, 0.1, 10000);
    camera.position.z = 2500;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x0a0a0a);
    threeCanvas.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // ========== SVG UML EDITOR ==========
    const umlEditor = document.getElementById('uml-editor');
    const umlSvg = document.getElementById('uml-svg');
    const nodesLayer = document.getElementById('nodes-layer');
    const connectionsLayer = document.getElementById('connections-layer');

    // Grid size in pixels (for rendering)
    const GRID_SIZE = 20;

    // UML Editor state - positions stored as grid units (integers)
    let umlNodes = [];
    let selectedNodeId = null;
    let dragState = null;

    // Viewport/pan state
    let viewBox = { x: 0, y: 0, width: 2000, height: 1500 };
    let panState = null;

    function updateViewBox() {
      umlSvg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`);
    }

    // Zoom state
    const baseViewBox = { width: 2000, height: 1500 };
    let zoomLevel = 1;
    const minZoom = 0.25;
    const maxZoom = 4;
    const zoomStep = 0.25;

    function updateZoomDisplay() {
      const zoomEl = document.getElementById('zoom-level');
      if (zoomEl) {
        zoomEl.textContent = Math.round(zoomLevel * 100) + '%';
      }
    }

    function zoom(delta, centerX = null, centerY = null) {
      const oldZoom = zoomLevel;
      zoomLevel = Math.max(minZoom, Math.min(maxZoom, zoomLevel + delta));

      if (zoomLevel === oldZoom) return;

      // Calculate new viewBox dimensions
      const newWidth = baseViewBox.width / zoomLevel;
      const newHeight = baseViewBox.height / zoomLevel;

      // If center point provided, zoom towards that point
      if (centerX !== null && centerY !== null) {
        // Convert screen coords to SVG coords
        const container = umlEditor.getBoundingClientRect();
        const svgX = viewBox.x + (centerX - container.left) * (viewBox.width / container.width);
        const svgY = viewBox.y + (centerY - container.top) * (viewBox.height / container.height);

        // Adjust viewBox to keep the point under cursor
        const ratioX = (svgX - viewBox.x) / viewBox.width;
        const ratioY = (svgY - viewBox.y) / viewBox.height;
        viewBox.x = svgX - ratioX * newWidth;
        viewBox.y = svgY - ratioY * newHeight;
      } else {
        // Zoom towards center
        const centerSvgX = viewBox.x + viewBox.width / 2;
        const centerSvgY = viewBox.y + viewBox.height / 2;
        viewBox.x = centerSvgX - newWidth / 2;
        viewBox.y = centerSvgY - newHeight / 2;
      }

      viewBox.width = newWidth;
      viewBox.height = newHeight;
      updateViewBox();
      updateZoomDisplay();
    }

    function zoomIn() {
      zoom(zoomStep);
    }

    function zoomOut() {
      zoom(-zoomStep);
    }

    // Mousewheel zoom
    umlEditor.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? -zoomStep : zoomStep;
      zoom(delta, e.clientX, e.clientY);
    }, { passive: false });

    // Convert grid units to pixels
    function gridToPixels(units) {
      return units * GRID_SIZE;
    }

    // Convert pixels to grid units (snapped)
    function pixelsToGrid(pixels) {
      return Math.round(pixels / GRID_SIZE);
    }

    // Left mouse button panning on background
    umlSvg.addEventListener('mousedown', (e) => {
      // Only pan if clicking on background (svg itself or the grid rect)
      if (e.button === 0 && (e.target === umlSvg || e.target.tagName === 'rect' && !e.target.classList.contains('node-bg'))) {
        e.preventDefault();
        umlEditor.classList.add('panning');
        panState = {
          startX: e.clientX,
          startY: e.clientY,
          startViewX: viewBox.x,
          startViewY: viewBox.y
        };
      }
    });

    document.addEventListener('mousemove', (e) => {
      if (panState) {
        const dx = e.clientX - panState.startX;
        const dy = e.clientY - panState.startY;

        // Only count as pan if moved more than a few pixels
        if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
          didPan = true;
        }

        // Scale movement based on viewBox/container ratio
        const container = umlEditor.getBoundingClientRect();
        const scaleX = viewBox.width / container.width;
        const scaleY = viewBox.height / container.height;
        viewBox.x = panState.startViewX - dx * scaleX;
        viewBox.y = panState.startViewY - dy * scaleY;
        updateViewBox();
      }
    });

    document.addEventListener('mouseup', (e) => {
      if (panState) {
        umlEditor.classList.remove('panning');
        panState = null;
      }
    });

    // Create SVG UML node
    function createSvgNode(node, index) {
      const headerHeight = node.stereotype ? 50 : 40;
      const lineHeight = 16;
      const padding = 10;
      const charWidth = 7; // Approximate width per character for monospace font
      const minWidth = 140;
      const maxWidth = 320;

      // Calculate width based on longest text line
      let maxTextLength = node.name.length;
      if (node.properties) {
        node.properties.forEach(p => { maxTextLength = Math.max(maxTextLength, p.length); });
      }
      if (node.methods) {
        node.methods.forEach(m => { maxTextLength = Math.max(maxTextLength, m.length); });
      }
      const calculatedWidth = maxTextLength * charWidth + padding * 2;
      const nodeWidth = Math.min(maxWidth, Math.max(minWidth, calculatedWidth));

      const propsHeight = (node.properties?.length || 0) * lineHeight + padding;
      const methodsHeight = (node.methods?.length || 0) * lineHeight + padding;
      const totalHeight = headerHeight + propsHeight + methodsHeight + padding;

      // Convert grid units to pixels for rendering
      const x = gridToPixels(node.x ?? (node.col * 13 + 3));
      const y = gridToPixels(node.y ?? (node.row * 15 + 3));

      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.setAttribute('class', 'uml-node-group');
      g.setAttribute('data-id', node.id || `node-${index}`);
      g.setAttribute('transform', `translate(${x}, ${y})`);

      // Background
      const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      bg.setAttribute('class', 'node-bg');
      bg.setAttribute('width', nodeWidth);
      bg.setAttribute('height', totalHeight);
      bg.setAttribute('rx', '4');
      g.appendChild(bg);

      // Header background
      const headerBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      headerBg.setAttribute('class', `node-header-bg ${node.type === 'interface' ? 'interface' : ''}`);
      headerBg.setAttribute('width', nodeWidth);
      headerBg.setAttribute('height', headerHeight);
      headerBg.setAttribute('rx', '4');
      g.appendChild(headerBg);

      // Border
      const border = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      border.setAttribute('class', 'node-border');
      border.setAttribute('width', nodeWidth);
      border.setAttribute('height', totalHeight);
      border.setAttribute('rx', '4');
      g.appendChild(border);

      // Header divider
      const headerDiv = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      headerDiv.setAttribute('class', 'node-divider');
      headerDiv.setAttribute('x1', '0');
      headerDiv.setAttribute('y1', headerHeight);
      headerDiv.setAttribute('x2', nodeWidth);
      headerDiv.setAttribute('y2', headerHeight);
      g.appendChild(headerDiv);

      let textY = 20;

      // Stereotype
      if (node.stereotype) {
        const stereo = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        stereo.setAttribute('class', 'node-stereotype');
        stereo.setAttribute('x', nodeWidth / 2);
        stereo.setAttribute('y', textY);
        stereo.setAttribute('text-anchor', 'middle');
        stereo.textContent = node.stereotype;
        g.appendChild(stereo);
        textY += 18;
      }

      // Name
      const name = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      name.setAttribute('class', 'node-name');
      name.setAttribute('x', nodeWidth / 2);
      name.setAttribute('y', textY + 5);
      name.setAttribute('text-anchor', 'middle');
      name.textContent = node.name;
      g.appendChild(name);

      // Properties
      let memberY = headerHeight + padding + 12;
      if (node.properties && node.properties.length > 0) {
        node.properties.forEach(prop => {
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('class', 'node-member');
          text.setAttribute('x', padding);
          text.setAttribute('y', memberY);
          text.textContent = prop;
          g.appendChild(text);
          memberY += lineHeight;
        });

        // Divider before methods
        if (node.methods && node.methods.length > 0) {
          const div = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          div.setAttribute('class', 'node-divider');
          div.setAttribute('x1', '0');
          div.setAttribute('y1', memberY - 4);
          div.setAttribute('x2', nodeWidth);
          div.setAttribute('y2', memberY - 4);
          g.appendChild(div);
          memberY += 8;
        }
      }

      // Methods
      if (node.methods && node.methods.length > 0) {
        node.methods.forEach(method => {
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('class', 'node-member');
          text.setAttribute('x', padding);
          text.setAttribute('y', memberY);
          text.textContent = method;
          g.appendChild(text);
          memberY += lineHeight;
        });
      }

      // Store dimensions for connections
      g.dataset.width = nodeWidth;
      g.dataset.height = totalHeight;

      return g;
    }

    // Render all UML nodes
    function renderUmlNodes() {
      nodesLayer.innerHTML = '';
      connectionsLayer.innerHTML = '';

      umlNodes.forEach((node, i) => {
        const svgNode = createSvgNode(node, i);
        nodesLayer.appendChild(svgNode);

        // Add event listeners
        svgNode.addEventListener('mousedown', (e) => startDrag(e, node));
        svgNode.addEventListener('click', (e) => selectNode(e, node));
      });

      // Render connections
      renderConnections();
    }

    // Render connection lines between nodes using explicit connections from pattern
    function renderConnections() {
      connectionsLayer.innerHTML = '';

      // Get connections from current pattern
      const patternId = params.selectedPattern;
      const pattern = customPatterns[patternId] || patternDefinitions[patternId];
      if (!pattern || !pattern.connections) return;

      pattern.connections.forEach(conn => {
        const fromNode = umlNodes.find(n => n.id === conn.from);
        const toNode = umlNodes.find(n => n.id === conn.to);
        if (!fromNode || !toNode) return;

        const fromEl = nodesLayer.querySelector(`[data-id="${conn.from}"]`);
        const toEl = nodesLayer.querySelector(`[data-id="${conn.to}"]`);
        if (!fromEl || !toEl) return;

        // Get positions and dimensions
        const fromX = gridToPixels(fromNode.x);
        const fromY = gridToPixels(fromNode.y);
        const toX = gridToPixels(toNode.x);
        const toY = gridToPixels(toNode.y);

        const fromWidth = parseFloat(fromEl.dataset.width);
        const fromHeight = parseFloat(fromEl.dataset.height);
        const toWidth = parseFloat(toEl.dataset.width);
        const toHeight = parseFloat(toEl.dataset.height);

        // Calculate connection points (center of edges)
        let startX, startY, endX, endY;

        // Determine best connection points based on relative positions
        const fromCenterX = fromX + fromWidth / 2;
        const fromCenterY = fromY + fromHeight / 2;
        const toCenterX = toX + toWidth / 2;
        const toCenterY = toY + toHeight / 2;

        // Connect from top of "from" to bottom of "to" (child to parent)
        if (fromCenterY > toCenterY) {
          startX = fromCenterX;
          startY = fromY;
          endX = toCenterX;
          endY = toY + toHeight;
        } else {
          // Connect from bottom of "from" to top of "to"
          startX = fromCenterX;
          startY = fromY + fromHeight;
          endX = toCenterX;
          endY = toY;
        }

        // For horizontal relationships, use side connections
        if (Math.abs(fromCenterY - toCenterY) < 50) {
          if (fromCenterX < toCenterX) {
            startX = fromX + fromWidth;
            startY = fromCenterY;
            endX = toX;
            endY = toCenterY;
          } else {
            startX = fromX;
            startY = fromCenterY;
            endX = toX + toWidth;
            endY = toCenterY;
          }
        }

        // Create path
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        line.setAttribute('class', `connection-line ${conn.type}`);

        // Calculate control points for smooth curve
        const midX = (startX + endX) / 2;
        const midY = (startY + endY) / 2;

        if (Math.abs(startY - endY) > Math.abs(startX - endX)) {
          // More vertical - use vertical bezier
          line.setAttribute('d', `M ${startX} ${startY} C ${startX} ${midY}, ${endX} ${midY}, ${endX} ${endY}`);
        } else {
          // More horizontal - use horizontal bezier
          line.setAttribute('d', `M ${startX} ${startY} C ${midX} ${startY}, ${midX} ${endY}, ${endX} ${endY}`);
        }

        connectionsLayer.appendChild(line);

        // Add arrow head based on connection type
        const arrowSize = 12;
        const angle = Math.atan2(endY - startY, endX - startX);

        const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        arrow.setAttribute('class', `connection-arrow ${conn.type}`);

        if (conn.type === 'aggregation' || conn.type === 'composition') {
          // Diamond shape for aggregation/composition (at start of line)
          const diamondSize = 10;
          const dx = Math.cos(angle) * diamondSize;
          const dy = Math.sin(angle) * diamondSize;
          const px = -Math.sin(angle) * diamondSize * 0.5;
          const py = Math.cos(angle) * diamondSize * 0.5;

          // Diamond at the "from" end
          const d1x = startX + dx;
          const d1y = startY + dy;
          const d2x = startX + dx * 0.5 + px;
          const d2y = startY + dy * 0.5 + py;
          const d3x = startX;
          const d3y = startY;
          const d4x = startX + dx * 0.5 - px;
          const d4y = startY + dy * 0.5 - py;

          arrow.setAttribute('points', `${d1x},${d1y} ${d2x},${d2y} ${d3x},${d3y} ${d4x},${d4y}`);
        } else {
          // Triangle arrow for other types (at end of line)
          const arrowX1 = endX - arrowSize * Math.cos(angle - Math.PI / 6);
          const arrowY1 = endY - arrowSize * Math.sin(angle - Math.PI / 6);
          const arrowX2 = endX - arrowSize * Math.cos(angle + Math.PI / 6);
          const arrowY2 = endY - arrowSize * Math.sin(angle + Math.PI / 6);

          arrow.setAttribute('points', `${endX},${endY} ${arrowX1},${arrowY1} ${arrowX2},${arrowY2}`);
        }
        connectionsLayer.appendChild(arrow);

        // Add label if present
        if (conn.label) {
          const labelX = (startX + endX) / 2;
          const labelY = (startY + endY) / 2 - 8;

          const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          label.setAttribute('x', labelX);
          label.setAttribute('y', labelY);
          label.setAttribute('class', 'connection-label');
          label.setAttribute('text-anchor', 'middle');
          label.textContent = conn.label;
          connectionsLayer.appendChild(label);
        }
      });
    }

    // Drag functionality
    function startDrag(e, node) {
      if (e.button !== 0) return;
      e.stopPropagation();

      const nodeEl = e.currentTarget;

      // Convert screen coords to SVG coords
      const container = umlEditor.getBoundingClientRect();
      const scaleX = viewBox.width / container.width;
      const scaleY = viewBox.height / container.height;

      dragState = {
        node,
        nodeEl,
        startGridX: node.x,
        startGridY: node.y,
        startMouseX: e.clientX,
        startMouseY: e.clientY,
        scaleX,
        scaleY,
        lockedAxis: null // Will be set when shift is held
      };

      document.addEventListener('mousemove', onDrag);
      document.addEventListener('mouseup', endDrag);
    }

    function onDrag(e) {
      if (!dragState) return;

      // Calculate pixel delta
      let dxPixels = (e.clientX - dragState.startMouseX) * dragState.scaleX;
      let dyPixels = (e.clientY - dragState.startMouseY) * dragState.scaleY;

      // Shift key locks to single axis
      if (e.shiftKey) {
        // Determine which axis to lock to (based on which has more movement)
        if (dragState.lockedAxis === null) {
          if (Math.abs(dxPixels) > Math.abs(dyPixels) && Math.abs(dxPixels) > GRID_SIZE / 2) {
            dragState.lockedAxis = 'x';
          } else if (Math.abs(dyPixels) > GRID_SIZE / 2) {
            dragState.lockedAxis = 'y';
          }
        }

        // Apply axis lock
        if (dragState.lockedAxis === 'x') {
          dyPixels = 0;
        } else if (dragState.lockedAxis === 'y') {
          dxPixels = 0;
        }
      } else {
        // Reset locked axis when shift is released
        dragState.lockedAxis = null;
      }

      // Convert pixel delta to grid units
      const dxGrid = pixelsToGrid(dxPixels);
      const dyGrid = pixelsToGrid(dyPixels);

      // Calculate new grid position
      const newGridX = dragState.startGridX + dxGrid;
      const newGridY = dragState.startGridY + dyGrid;

      // Update node position (in grid units)
      dragState.node.x = newGridX;
      dragState.node.y = newGridY;

      // Update visual (convert to pixels)
      const pixelX = gridToPixels(newGridX);
      const pixelY = gridToPixels(newGridY);
      dragState.nodeEl.setAttribute('transform', `translate(${pixelX}, ${pixelY})`);

      // Update position inputs if this node is selected (show grid units)
      if (selectedNodeId === (dragState.node.id || `node-${umlNodes.indexOf(dragState.node)}`)) {
        document.getElementById('nodePositionX').value = newGridX;
        document.getElementById('nodePositionY').value = newGridY;
      }

      renderConnections();
    }

    function endDrag() {
      dragState = null;
      document.removeEventListener('mousemove', onDrag);
      document.removeEventListener('mouseup', endDrag);
      autoSave();
      autoSavePattern();
    }

    // Selection
    function selectNode(e, node) {
      e.stopPropagation();

      // Deselect previous
      document.querySelectorAll('.uml-node-group.selected').forEach(el => el.classList.remove('selected'));

      // Select new
      const nodeEl = e.currentTarget;
      nodeEl.classList.add('selected');
      selectedNodeId = node.id || `node-${umlNodes.indexOf(node)}`;

      // Show position controls
      const posControls = document.getElementById('node-position-controls');
      posControls.classList.add('visible');
      document.getElementById('selectedNodeName').textContent = node.name;
      document.getElementById('nodePositionX').value = node.x || 0;
      document.getElementById('nodePositionY').value = node.y || 0;
    }

    function deselectAll() {
      document.querySelectorAll('.uml-node-group.selected').forEach(el => el.classList.remove('selected'));
      selectedNodeId = null;
      document.getElementById('node-position-controls').classList.remove('visible');
    }

    // Position input handlers (values are in grid units)
    function updateNodePosition(axis, value) {
      if (!selectedNodeId) return;

      const node = umlNodes.find(n => (n.id || `node-${umlNodes.indexOf(n)}`) === selectedNodeId);
      if (!node) return;

      // Value is already in grid units (integer)
      const gridValue = Math.round(parseInt(value) || 0);
      node[axis] = gridValue;

      // Update input to show integer value
      document.getElementById(axis === 'x' ? 'nodePositionX' : 'nodePositionY').value = gridValue;

      // Re-render to update visual
      renderUmlNodes();

      // Re-select the node visually
      const nodeEl = nodesLayer.querySelector(`[data-id="${selectedNodeId}"]`);
      if (nodeEl) nodeEl.classList.add('selected');

      autoSave();
      autoSavePattern();
    }

    // Track if we panned (to avoid deselecting on pan end)
    let didPan = false;

    // Update pan tracking in mousemove
    const originalMouseMove = document.onmousemove;

    // Click on background to deselect (only if we didn't pan)
    umlSvg.addEventListener('click', (e) => {
      if (didPan) {
        didPan = false;
        return;
      }
      if (e.target === umlSvg || e.target.tagName === 'rect' && !e.target.classList.contains('node-bg')) {
        deselectAll();
      }
    });

    // Delete selected node
    function deleteSelectedNode() {
      if (!selectedNodeId) return;

      const index = umlNodes.findIndex(n => (n.id || `node-${umlNodes.indexOf(n)}`) === selectedNodeId);
      if (index !== -1) {
        umlNodes.splice(index, 1);
        deselectAll();
        renderUmlNodes();
        autoSavePattern();
      }
    }

    // Add new node
    function addNewNode() {
      // Find position for new node (in grid units)
      const maxX = umlNodes.length > 0 ? Math.max(...umlNodes.map(n => n.x ?? 3)) : 3;

      const newNode = {
        id: `node-${Date.now()}`,
        name: `NewClass${umlNodes.length + 1}`,
        type: 'class',
        stereotype: null,
        properties: ['- data: string'],
        methods: ['+ execute(): void'],
        row: 0,
        col: 0,
        x: maxX + 13,  // Grid units
        y: 3           // Grid units
      };

      umlNodes.push(newNode);
      renderUmlNodes();
      autoSavePattern();
    }

    // Update UML editor from pattern
    function updateUmlFromPattern() {
      if (!currentPattern) return;

      // Positions in grid units (integers)
      // Use existing x/y if available (for custom patterns), otherwise calculate from row/col
      umlNodes = currentPattern.nodes.map((node, i) => ({
        ...node,
        id: node.id || `node-${i}`,
        x: node.x ?? (node.col * 13 + 3),
        y: node.y ?? (node.row * 15 + 3)
      }));

      renderUmlNodes();
    }

    // Patterns storage (loaded from JSON files)
    let customPatterns = {};
    // Empty patternDefinitions for backwards compatibility
    const patternDefinitions = {
      // Fallback pattern in case server isn't running
      'factory': {
        name: 'Factory Method (Default)',
        description: 'Default fallback pattern - start the server for full patterns.',
        nodes: [
          { id: 'node-0', name: 'Product', type: 'interface', stereotype: '«interface»', methods: ['+ use(): void'], properties: [], x: 6, y: 3 },
          { id: 'node-1', name: 'ConcreteProductA', type: 'class', stereotype: null, methods: ['+ use(): void'], properties: [], x: 1, y: 15 },
          { id: 'node-2', name: 'ConcreteProductB', type: 'class', stereotype: null, methods: ['+ use(): void'], properties: [], x: 11, y: 15 },
          { id: 'node-3', name: 'Creator', type: 'abstract', stereotype: '«abstract»', methods: ['+ factoryMethod(): Product', '+ operation(): void'], properties: [], x: 26, y: 2 },
          { id: 'node-4', name: 'ConcreteCreatorA', type: 'class', stereotype: null, methods: ['+ factoryMethod(): Product'], properties: [], x: 20, y: 15 },
          { id: 'node-5', name: 'ConcreteCreatorB', type: 'class', stereotype: null, methods: ['+ factoryMethod(): Product'], properties: [], x: 32, y: 15 }
        ],
        connections: [
          { from: 'node-1', to: 'node-0', type: 'implements' },
          { from: 'node-2', to: 'node-0', type: 'implements' },
          { from: 'node-4', to: 'node-3', type: 'extends' },
          { from: 'node-5', to: 'node-3', type: 'extends' },
          { from: 'node-3', to: 'node-0', type: 'dependency', label: '«creates»' }
        ],
        layouts: { '1': [] }
      }
    };

    // Layout variation tracking
    let currentLayout = '1';

    function saveCurrentLayout() {
      const patternId = params.selectedPattern;
      if (!patternId || !customPatterns[patternId]) return;

      // Initialize layouts object if needed
      if (!customPatterns[patternId].layouts) {
        customPatterns[patternId].layouts = {};
      }

      // Save current node positions to current layout
      customPatterns[patternId].layouts[currentLayout] = umlNodes.map(n => ({
        id: n.id,
        x: n.x,
        y: n.y
      }));
    }

    function loadLayout(layoutNum) {
      const patternId = params.selectedPattern;
      if (!patternId || !customPatterns[patternId]) return;

      const pattern = customPatterns[patternId];
      const layoutData = pattern.layouts?.[layoutNum];

      if (layoutData) {
        // Apply saved positions
        layoutData.forEach(saved => {
          const node = umlNodes.find(n => n.id === saved.id);
          if (node) {
            node.x = saved.x;
            node.y = saved.y;
          }
        });
      }
      // If no saved layout, keep current positions (they'll become this layout when saved)

      renderUmlNodes();
    }

    function switchLayout(layoutNum) {
      if (layoutNum === currentLayout) return;

      // Save current layout before switching
      saveCurrentLayout();

      // Update active button
      document.querySelectorAll('.layout-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelector(`.layout-btn[data-layout="${layoutNum}"]`)?.classList.add('active');

      // Switch and load new layout
      currentLayout = layoutNum;
      loadLayout(layoutNum);

      // Auto-save pattern with layout data
      autoSavePattern();
    }

    // Modal functions
    function openModal(modalId) {
      document.getElementById(modalId).classList.add('visible');
    }

    function closeModal(modalId) {
      document.getElementById(modalId).classList.remove('visible');
    }

    // Load custom patterns from JSON files via API
    async function loadCustomPatterns() {
      try {
        console.log('Loading patterns from API...');
        const response = await fetch('/api/patterns');
        if (response.ok) {
          const index = await response.json();
          console.log('Pattern index:', index);
          for (const patternId of index.patterns || []) {
            try {
              const patternResponse = await fetch(`/api/pattern/${patternId}`);
              if (patternResponse.ok) {
                customPatterns[patternId] = await patternResponse.json();
                console.log(`Loaded pattern: ${patternId}`);
              }
            } catch (e) {
              console.warn(`Failed to load pattern ${patternId}:`, e);
            }
          }
          updatePatternDropdown();
          console.log('Total patterns loaded:', Object.keys(customPatterns).length);
        } else {
          console.error('API returned error:', response.status);
          showNotification('Error: Make sure server is running (npm start)', 5000);
        }
      } catch (e) {
        console.error('Failed to load patterns:', e);
        showNotification('Error: Cannot connect to server. Run "npm start" first.', 5000);
      }
    }

    // Update pattern dropdown with all patterns
    function updatePatternDropdown() {
      const select = document.getElementById('patternSelect');
      if (!select) return;

      // Clear and repopulate
      select.innerHTML = '';

      // Add all patterns from JSON (custom patterns first)
      for (const [id, pattern] of Object.entries(customPatterns)) {
        const option = document.createElement('option');
        option.value = id;
        option.textContent = pattern.name;
        select.appendChild(option);
      }

      // Add fallback patterns if no custom patterns loaded
      if (Object.keys(customPatterns).length === 0) {
        for (const [id, pattern] of Object.entries(patternDefinitions)) {
          const option = document.createElement('option');
          option.value = id;
          option.textContent = pattern.name;
          select.appendChild(option);
        }
      }

      // Select the saved pattern if available
      const allPatterns = { ...patternDefinitions, ...customPatterns };
      if (params.selectedPattern && allPatterns[params.selectedPattern]) {
        select.value = params.selectedPattern;
      } else if (Object.keys(allPatterns).length > 0) {
        // Select first pattern if saved one doesn't exist
        select.value = Object.keys(allPatterns)[0];
        params.selectedPattern = select.value;
      }
    }

    // Create new pattern via API
    async function createNewPattern() {
      const nameInput = document.getElementById('newPatternName');
      const name = nameInput.value.trim();
      if (!name) {
        alert('Please enter a pattern name');
        return;
      }

      // Generate ID from name
      const id = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
      if (customPatterns[id]) {
        alert('A pattern with this name already exists');
        return;
      }

      // Create pattern with current nodes or empty
      const patternData = {
        name: name,
        description: 'Custom pattern',
        nodes: umlNodes.length > 0 ? JSON.parse(JSON.stringify(umlNodes)) : [
          {
            id: 'node-0',
            name: 'MyClass',
            type: 'class',
            stereotype: null,
            properties: ['- data: string'],
            methods: ['+ execute(): void'],
            row: 0,
            col: 0,
            x: 3,
            y: 3
          }
        ],
        layouts: {}
      };

      try {
        // Save pattern via API
        const response = await fetch(`/api/pattern/${id}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(patternData, null, 2)
        });

        if (response.ok) {
          customPatterns[id] = patternData;
          await savePatternIndex();
          updatePatternDropdown();
          document.getElementById('patternSelect').value = id;
          params.selectedPattern = id;
          generatePattern();
          updateUmlFromPattern();
          showNotification(`Pattern "${name}" created!`);
        }
      } catch (e) {
        console.error('Failed to create pattern:', e);
        alert('Failed to create pattern');
      }

      closeModal('newPatternModal');
      nameInput.value = '';
    }

    // Save pattern index via API
    async function savePatternIndex() {
      try {
        await fetch('/api/patterns', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ patterns: Object.keys(customPatterns) })
        });
      } catch (e) {
        console.warn('Failed to save pattern index:', e);
      }
    }

    // Save current pattern via API
    async function saveCurrentPattern() {
      const patternId = document.getElementById('patternSelect')?.value;
      if (!patternId || !customPatterns[patternId]) return;

      // Update custom pattern with current nodes
      customPatterns[patternId].nodes = JSON.parse(JSON.stringify(umlNodes));

      try {
        const response = await fetch(`/api/pattern/${patternId}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(customPatterns[patternId], null, 2)
        });
        if (response.ok) {
          showNotification(`Pattern "${customPatterns[patternId].name}" saved!`);
        }
      } catch (e) {
        console.error('Failed to save pattern:', e);
      }
    }

    // Delete pattern
    function showDeletePatternModal() {
      const patternId = document.getElementById('patternSelect')?.value;
      if (!patternId) return;

      // Can't delete built-in patterns
      if (patternDefinitions[patternId]) {
        alert('Cannot delete built-in patterns');
        return;
      }

      if (!customPatterns[patternId]) {
        alert('Pattern not found');
        return;
      }

      document.getElementById('deletePatternName').textContent = customPatterns[patternId].name;
      openModal('deletePatternModal');
    }

    async function confirmDeletePattern() {
      const patternId = document.getElementById('patternSelect')?.value;
      if (!patternId || !customPatterns[patternId]) {
        closeModal('deletePatternModal');
        return;
      }

      const name = customPatterns[patternId].name;

      // Delete via API
      try {
        await fetch(`/api/pattern/${patternId}`, { method: 'DELETE' });
      } catch (e) {
        console.warn('Failed to delete pattern file:', e);
      }

      // Remove from storage
      delete customPatterns[patternId];

      // Update index
      await savePatternIndex();

      // Update dropdown
      updatePatternDropdown();

      // Select first pattern
      const select = document.getElementById('patternSelect');
      const firstPattern = Object.keys(customPatterns)[0] || 'factory';
      select.value = firstPattern;
      params.selectedPattern = firstPattern;
      generatePattern();
      updateUmlFromPattern();

      closeModal('deletePatternModal');
      showNotification(`Pattern "${name}" deleted!`);
    }

    // Current pattern
    let currentPattern = null;

    function generatePattern() {
      const patternKey = document.getElementById('patternSelect')?.value || 'factory';

      // Load pattern from JSON (or fallback)
      const pattern = customPatterns[patternKey] || patternDefinitions[patternKey];
      if (!pattern) {
        console.warn('No pattern found for key:', patternKey);
        return null;
      }

      // Deep copy nodes from pattern JSON
      const nodes = JSON.parse(JSON.stringify(pattern.nodes));

      // Apply current layout positions if available
      const layoutData = pattern.layouts?.[currentLayout];
      if (layoutData) {
        layoutData.forEach(saved => {
          const node = nodes.find(n => n.id === saved.id);
          if (node) {
            node.x = saved.x;
            node.y = saved.y;
          }
        });
      }

      // Ensure all nodes have x/y coordinates
      nodes.forEach((n, i) => {
        if (n.x === undefined) n.x = i * 10;
        if (n.y === undefined) n.y = 0;
      });

      // Calculate bounds
      const xs = nodes.map(n => n.x);
      const ys = nodes.map(n => n.y);

      currentPattern = {
        nodes: nodes,
        connections: pattern.connections || [],
        minX: Math.min(...xs),
        maxX: Math.max(...xs),
        minY: Math.min(...ys),
        maxY: Math.max(...ys)
      };

      updatePatternDescription(pattern.description || '');
      return currentPattern;
    }

    function updatePatternDescription(desc) {
      const el = document.getElementById('patternDescription');
      if (el) el.textContent = desc;
    }

    // Activator particles
    const maxActivators = 10;
    const activatorPositions = new Float32Array(maxActivators * 3);
    const activatorVelocities = [];

    function initActivators() {
      const pattern = currentPattern || { minX: 0, maxX: 3, minY: 0, maxY: 3 };
      const extentX = (pattern.maxX - pattern.minX) || 3;
      const extentY = (pattern.maxY - pattern.minY) || 3;
      const gridSpacing = 18; // Must match preview spacing
      const gridExtent = Math.max(extentX, extentY) * gridSpacing;
      for (let i = 0; i < maxActivators; i++) {
        activatorPositions[i * 3] = (Math.random() - 0.5) * gridExtent * 2;
        activatorPositions[i * 3 + 1] = (Math.random() - 0.5) * gridExtent * 2;
        activatorPositions[i * 3 + 2] = (Math.random() - 0.5) * 200;

        activatorVelocities[i] = {
          x: (Math.random() - 0.5) * 2,
          y: (Math.random() - 0.5) * 2,
          z: (Math.random() - 0.5) * 0.5
        };
      }
    }

    function updateActivators(delta) {
      const pattern = currentPattern || { minX: 0, maxX: 3, minY: 0, maxY: 3 };
      const extentX = (pattern.maxX - pattern.minX) || 3;
      const extentY = (pattern.maxY - pattern.minY) || 3;
      const gridSpacing = 18; // Must match preview spacing
      const gridExtent = Math.max(extentX, extentY) * gridSpacing + 50;
      const speed = params.activatorSpeed * delta;

      for (let i = 0; i < maxActivators; i++) {
        activatorPositions[i * 3] += activatorVelocities[i].x * speed;
        activatorPositions[i * 3 + 1] += activatorVelocities[i].y * speed;
        activatorPositions[i * 3 + 2] += activatorVelocities[i].z * speed * 0.5;

        if (Math.abs(activatorPositions[i * 3]) > gridExtent) {
          activatorVelocities[i].x *= -1;
          activatorPositions[i * 3] = Math.sign(activatorPositions[i * 3]) * gridExtent;
        }
        if (Math.abs(activatorPositions[i * 3 + 1]) > gridExtent) {
          activatorVelocities[i].y *= -1;
          activatorPositions[i * 3 + 1] = Math.sign(activatorPositions[i * 3 + 1]) * gridExtent;
        }
        if (Math.abs(activatorPositions[i * 3 + 2]) > 150) {
          activatorVelocities[i].z *= -1;
        }
      }
    }

    // Render UML node to canvas
    function createUMLTexture(node) {
      const canvas = document.getElementById('text-canvas');
      const ctx = canvas.getContext('2d');

      const scale = 2;
      canvas.width = params.nodeWidth * scale;
      canvas.height = params.nodeHeight * scale;

      // Reset transform before scaling (setting canvas.width already does this, but be explicit)
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(scale, scale);

      // Background
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, params.nodeWidth, params.nodeHeight);

      // Border
      ctx.strokeStyle = '#d4a855';
      ctx.lineWidth = 2;
      ctx.strokeRect(3, 3, params.nodeWidth - 6, params.nodeHeight - 6);

      // Header background
      ctx.fillStyle = '#d4a855';
      ctx.globalAlpha = node.type === 'interface' ? 0.15 : 0.08;
      ctx.fillRect(3, 3, params.nodeWidth - 6, 55);
      ctx.globalAlpha = 1;

      // Header separator
      ctx.beginPath();
      ctx.moveTo(3, 58);
      ctx.lineTo(params.nodeWidth - 3, 58);
      ctx.strokeStyle = '#d4a855';
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.fillStyle = '#d4a855';

      // Use monospace font (more reliable across systems)
      const fontFamily = 'monospace';

      // Stereotype (if any)
      let nameY = 38;
      if (node.stereotype) {
        ctx.font = `italic 11px ${fontFamily}`;
        ctx.textAlign = 'center';
        ctx.globalAlpha = 0.7;
        ctx.fillText(node.stereotype, params.nodeWidth / 2, 22);
        ctx.globalAlpha = 1;
        nameY = 45;
      }

      // Class name
      ctx.font = `bold 16px ${fontFamily}`;
      ctx.textAlign = 'center';
      ctx.fillText(node.name, params.nodeWidth / 2, nameY);

      // Properties section
      ctx.font = `10px ${fontFamily}`;
      ctx.textAlign = 'left';
      ctx.globalAlpha = 0.7;

      let yPos = 75;
      const lineHeight = 14;

      // Draw properties
      if (node.properties && node.properties.length > 0) {
        node.properties.forEach((prop) => {
          ctx.fillText(prop, 10, yPos);
          yPos += lineHeight;
        });

        // Separator between properties and methods
        if (node.methods && node.methods.length > 0) {
          ctx.beginPath();
          ctx.moveTo(3, yPos - 2);
          ctx.lineTo(params.nodeWidth - 3, yPos - 2);
          ctx.strokeStyle = '#d4a85544';
          ctx.stroke();
          yPos += 8;
        }
      }

      // Draw methods
      if (node.methods && node.methods.length > 0) {
        node.methods.forEach((method) => {
          ctx.fillText(method, 10, yPos);
          yPos += lineHeight;
        });
      }

      ctx.globalAlpha = 1;
      return canvas;
    }

    // Sample particles from canvas
    function sampleParticlesFromCanvas(canvas, density, offsetX, offsetY) {
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;

      const particles = [];
      const width = canvas.width;
      const height = canvas.height;

      // Scale factor: canvas is rendered at 2x, we want world units at 1/4 scale
      const scale = 0.25;
      const worldWidth = width * scale;
      const worldHeight = height * scale;

      for (let y = 0; y < height; y += density) {
        for (let x = 0; x < width; x += density) {
          const i = (Math.floor(y) * width + Math.floor(x)) * 4;
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];

          const brightness = (r + g + b) / 3;
          if (brightness > 30) {
            particles.push({
              x: (x * scale) - worldWidth / 2 + offsetX,
              y: -(y * scale) + worldHeight / 2 + offsetY,
              z: (Math.random() - 0.5) * 2,
              color: { r: r / 255, g: g / 255, b: b / 255 },
              brightness: brightness / 255
            });
          }
        }
      }

      return particles;
    }

    // Create particle system
    function createParticleSystem(singleNode = false) {
      let allParticles = [];

      // Generate pattern if not already done
      if (!currentPattern) {
        generatePattern();
      }

      const pattern = currentPattern;

      if (!pattern || !pattern.nodes || pattern.nodes.length === 0) {
        console.error('No pattern or nodes available for particle system');
        // Return empty particle system
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(0), 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(0), 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(new Float32Array(0), 1));
        geometry.setAttribute('original', new THREE.BufferAttribute(new Float32Array(0), 3));
        return new THREE.Points(geometry, new THREE.PointsMaterial({ size: 1 }));
      }

      if (singleNode) {
        // Single node for noise generator tab - use first node from pattern
        const node = pattern.nodes[0] || {
          name: 'IComponent',
          type: 'interface',
          stereotype: '«interface»',
          methods: ['+ execute(): void'],
          properties: []
        };
        createUMLTexture(node);
        allParticles = sampleParticlesFromCanvas(
          document.getElementById('text-canvas'),
          params.density,
          0, 0
        );
      } else {
        // Full pattern layout using x/y coordinates from JSON
        const gridSpacing = 18; // Spacing per grid unit

        // Center the pattern around origin
        const centerX = (pattern.minX + pattern.maxX) / 2;
        const centerY = (pattern.minY + pattern.maxY) / 2;

        for (const node of pattern.nodes) {
          // Use x/y grid coordinates, centered
          const offsetX = ((node.x || 0) - centerX) * gridSpacing;
          const offsetY = (centerY - (node.y || 0)) * gridSpacing;

          // Render node to canvas and get its size
          const canvas = createUMLTexture(node);
          const nodeWidth = canvas.width / 4; // Scale factor from canvas
          const nodeHeight = canvas.height / 4;

          // Store world position and bounds for connections
          nodeWorldPositions[node.id] = {
            x: offsetX,
            y: offsetY,
            width: nodeWidth,
            height: nodeHeight,
            left: offsetX - nodeWidth / 2,
            right: offsetX + nodeWidth / 2,
            top: offsetY + nodeHeight / 2,
            bottom: offsetY - nodeHeight / 2
          };

          const nodeParticles = sampleParticlesFromCanvas(
            canvas,
            params.density,
            offsetX,
            offsetY
          );
          allParticles = allParticles.concat(nodeParticles);
        }
      }

      console.log(`Created ${allParticles.length} particles`);

      const geometry = new THREE.BufferGeometry();

      const positions = new Float32Array(allParticles.length * 3);
      const colors = new Float32Array(allParticles.length * 3);
      const sizes = new Float32Array(allParticles.length);
      const originals = new Float32Array(allParticles.length * 3);

      allParticles.forEach((p, i) => {
        positions[i * 3] = p.x;
        positions[i * 3 + 1] = p.y;
        positions[i * 3 + 2] = p.z;

        originals[i * 3] = p.x;
        originals[i * 3 + 1] = p.y;
        originals[i * 3 + 2] = p.z;

        colors[i * 3] = p.color.r;
        colors[i * 3 + 1] = p.color.g;
        colors[i * 3 + 2] = p.color.b;

        sizes[i] = params.particleSize + p.brightness * 1.5;
      });

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      geometry.setAttribute('original', new THREE.BufferAttribute(originals, 3));

      const useNoise = currentTab !== 'uml-generator';
      const useActivation = currentTab === 'total-preview';

      const material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          pixelRatio: { value: renderer.getPixelRatio() },
          noiseType: { value: 1 },
          noiseScale: { value: params.noiseScale },
          noiseSpeed: { value: params.noiseSpeed },
          displacementXY: { value: params.displacementXY },
          displacementZ: { value: params.displacementZ },
          blockSize: { value: params.blockSize },
          turbulence: { value: params.turbulence },
          lacunarity: { value: params.lacunarity },
          persistence: { value: params.persistence },
          sharpness: { value: params.sharpness },
          contrast: { value: params.contrast },
          particleSizeMultiplier: { value: 1.0 },
          particleOpacity: { value: params.particleOpacity },
          activatorPositions: { value: activatorPositions },
          activatorCount: { value: params.activatorCount },
          activationRadius: { value: params.activationRadius },
          falloff: { value: params.falloff },
          useNoise: { value: useNoise },
          useActivation: { value: useActivation },
          glitchIntensity: { value: params.glitchIntensity || 1.0 },
          glitchChance: { value: params.glitchChance || 0.3 },
          glitchMaskScale: { value: params.glitchMaskScale || 0.01 },
          glitchSpeed: { value: params.glitchSpeed || 2.0 },
          rgbSplit: { value: params.rgbSplit || 1.0 }
        },
        vertexShader: `
          attribute float size;
          attribute vec3 original;
          varying vec3 vColor;
          varying float vActivation;
          uniform float time;
          uniform float pixelRatio;
          uniform int noiseType;
          uniform float noiseScale;
          uniform float noiseSpeed;
          uniform float displacementXY;
          uniform float displacementZ;
          uniform float blockSize;
          uniform int turbulence;
          uniform float lacunarity;
          uniform float persistence;
          uniform float sharpness;
          uniform float contrast;
          uniform float particleSizeMultiplier;
          uniform float activatorPositions[30];
          uniform int activatorCount;
          uniform float activationRadius;
          uniform float falloff;
          uniform bool useNoise;
          uniform bool useActivation;
          uniform float glitchIntensity;
          uniform float glitchChance;
          uniform float glitchMaskScale;
          uniform float glitchSpeed;
          uniform float rgbSplit;
          varying float vRgbOffset;

          vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
          vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
          vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
          vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

          float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0);
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i = floor(v + dot(v, C.yyy));
            vec3 x0 = v - i + dot(i, C.xxx);
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min(g.xyz, l.zxy);
            vec3 i2 = max(g.xyz, l.zxy);
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute(permute(permute(
                i.z + vec4(0.0, i1.z, i2.z, 1.0))
              + i.y + vec4(0.0, i1.y, i2.y, 1.0))
              + i.x + vec4(0.0, i1.x, i2.x, 1.0));
            float n_ = 0.142857142857;
            vec3 ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_);
            vec4 x = x_ * ns.x + ns.yyyy;
            vec4 y = y_ * ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4(x.xy, y.xy);
            vec4 b1 = vec4(x.zw, y.zw);
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
            vec3 p0 = vec3(a0.xy, h.x);
            vec3 p1 = vec3(a0.zw, h.y);
            vec3 p2 = vec3(a1.xy, h.z);
            vec3 p3 = vec3(a1.zw, h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
            p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
          }

          float squareNoise(vec3 v, float gridSize) {
            vec3 gridPos = floor(v * gridSize) / gridSize;
            return snoise(gridPos);
          }

          float ridgedNoise(vec3 v) {
            return 1.0 - abs(snoise(v)) * 2.0;
          }

          float cellularNoise(vec3 v) {
            vec3 i = floor(v);
            vec3 f = fract(v);
            float minDist = 1.0;
            for (int x = -1; x <= 1; x++) {
              for (int y = -1; y <= 1; y++) {
                vec3 neighbor = vec3(float(x), float(y), 0.0);
                vec3 point = neighbor + vec3(
                  fract(sin(dot(i + neighbor, vec3(127.1, 311.7, 74.7))) * 43758.5453),
                  fract(sin(dot(i + neighbor, vec3(269.5, 183.3, 246.1))) * 43758.5453),
                  0.0
                );
                float dist = length(f - point);
                minDist = min(minDist, dist);
              }
            }
            return minDist * 2.0 - 1.0;
          }

          float getNoiseValue(vec3 v, float gridSize, int type) {
            if (type == 0) return snoise(v);
            if (type == 1) return squareNoise(v, gridSize);
            if (type == 2) return ridgedNoise(v);
            if (type == 3) return cellularNoise(v);
            return snoise(v);
          }

          float turbulentNoise(vec3 v, float gridSize, int octaves, float lac, float pers, int type) {
            float total = 0.0;
            float amplitude = 1.0;
            float frequency = 1.0;
            float maxValue = 0.0;

            for (int i = 0; i < 8; i++) {
              if (i >= octaves) break;
              total += getNoiseValue(v * frequency, gridSize * frequency, type) * amplitude;
              maxValue += amplitude;
              amplitude *= pers;
              frequency *= lac;
            }

            return total / maxValue;
          }

          float applySharpness(float v, float s) {
            return sign(v) * pow(abs(v), 1.0 / s);
          }

          float applyContrast(float v, float c) {
            return clamp(v * c, -1.0, 1.0);
          }

          float getActivation() {
            // For noise preview tab - always active
            if (!useActivation) return 1.0;

            // Two-layer system: spatial + temporal randomness

            // Layer 1: Spatial - WHERE glitches can occur (slow-moving zones)
            vec3 spatialCoord = original * glitchMaskScale;
            spatialCoord += vec3(
              sin(time * 0.2) * 20.0 + cos(time * 0.15) * 15.0,
              cos(time * 0.17) * 18.0 + sin(time * 0.23) * 12.0,
              sin(time * 0.13) * 10.0
            );
            float spatialNoise = snoise(spatialCoord);

            // Layer 2: Temporal - WHEN glitches fire
            // Quantize time so glitches HOLD for a duration instead of flickering
            float holdTime = 0.3; // How long each glitch holds (seconds)
            float quantizedTime = floor(time / holdTime) * holdTime;
            vec3 temporalCoord = vec3(
              quantizedTime * glitchSpeed + original.x * 0.002,
              quantizedTime * glitchSpeed * 1.3 + original.y * 0.002,
              original.z * 0.01
            );
            float temporalNoise = snoise(temporalCoord);

            // Thresholds - more frequent glitches
            float spatialThreshold = 1.0 - glitchChance * 1.5;  // More generous
            float temporalThreshold = 0.5;  // 50% of temporal peaks (was 75%)

            // Must pass BOTH thresholds
            if (spatialNoise < spatialThreshold) return 0.0;
            if (temporalNoise < temporalThreshold) return 0.0;

            // Activation strength
            float spatialStrength = (spatialNoise - spatialThreshold) / max(1.0 - spatialThreshold, 0.01);
            float temporalStrength = (temporalNoise - temporalThreshold) / (1.0 - temporalThreshold);

            float activation = spatialStrength * temporalStrength;
            activation = smoothstep(0.0, 0.3, activation);

            return activation * glitchIntensity;
          }

          void main() {
            vColor = color;
            vec3 pos = position;

            float activation = getActivation();
            vActivation = activation;

            // Only apply noise displacement if enabled
            if (useNoise) {
              vec3 noiseCoord = vec3(
                original.x * noiseScale,
                original.y * noiseScale,
                original.z * noiseScale * 0.3 + time * noiseSpeed
              );
              float grid = blockSize / 1000.0 * 100.0;

              float noiseX = turbulentNoise(noiseCoord, grid, turbulence, lacunarity, persistence, noiseType);
              float noiseY = turbulentNoise(noiseCoord + vec3(100.0, 50.0, 25.0), grid, turbulence, lacunarity, persistence, noiseType);
              float noiseZ = turbulentNoise(noiseCoord + vec3(200.0, 150.0, 75.0), grid, turbulence, lacunarity, persistence, noiseType);

              noiseX = applyContrast(applySharpness(noiseX, sharpness), contrast);
              noiseY = applyContrast(applySharpness(noiseY, sharpness), contrast);
              noiseZ = applyContrast(applySharpness(noiseZ, sharpness), contrast);

              pos.x += noiseX * displacementXY * activation;
              pos.y += noiseY * displacementXY * activation;
              pos.z += noiseZ * displacementZ * activation;

              // Pixel sort effect: horizontal streak based on brightness when glitching
              float brightness = (color.r + color.g + color.b) / 3.0;
              float sortStreak = brightness * activation * rgbSplit * 3.0;
              pos.x += sortStreak;
            }

            // RGB split: offset position slightly for color channel separation
            vRgbOffset = activation * rgbSplit * 0.02;

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = size * pixelRatio * particleSizeMultiplier * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          varying vec3 vColor;
          varying float vActivation;
          varying float vRgbOffset;
          uniform float particleOpacity;

          void main() {
            vec2 center = gl_PointCoord - vec2(0.5);
            float dist = length(center);
            if (dist > 0.5) discard;

            float alpha = 1.0 - smoothstep(0.3, 0.5, dist);

            // RGB split effect: offset color channels based on position within particle
            vec3 finalColor = vColor;
            if (vRgbOffset > 0.001) {
              // Shift red channel one way, blue the other
              float redShift = center.x * vRgbOffset * 20.0;
              float blueShift = -center.x * vRgbOffset * 20.0;

              finalColor.r = vColor.r * (1.0 + redShift);
              finalColor.g = vColor.g;
              finalColor.b = vColor.b * (1.0 + blueShift);

              // Add some color fringing at edges
              float edgeFactor = smoothstep(0.2, 0.5, dist);
              finalColor.r += edgeFactor * vRgbOffset * 2.0;
              finalColor.b += edgeFactor * vRgbOffset * 1.5;
            }

            // Brighten during glitch
            finalColor *= (1.0 + vActivation * 0.3);

            gl_FragColor = vec4(finalColor, alpha * particleOpacity);
          }
        `,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        vertexColors: true
      });

      return new THREE.Points(geometry, material);
    }

    // Create gradient texture for activation field
    function createGradientTexture() {
      const size = 256;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');

      // Create radial gradient: center is fully opaque, edge is transparent
      const gradient = ctx.createRadialGradient(
        size / 2, size / 2, 0,
        size / 2, size / 2, size / 2
      );
      gradient.addColorStop(0, 'rgba(212, 168, 85, 0.4)');
      gradient.addColorStop(0.3, 'rgba(212, 168, 85, 0.25)');
      gradient.addColorStop(0.6, 'rgba(212, 168, 85, 0.1)');
      gradient.addColorStop(1, 'rgba(212, 168, 85, 0)');

      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, size, size);

      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      return texture;
    }

    // Activator visualization
    let activatorMeshes = [];
    let radiusFieldMeshes = [];
    let gradientFieldMeshes = [];
    let gradientTexture = null;

    function createActivatorVisuals() {
      // Clean up existing meshes
      activatorMeshes.forEach(m => { scene.remove(m); m.geometry.dispose(); m.material.dispose(); });
      radiusFieldMeshes.forEach(m => { scene.remove(m); m.geometry.dispose(); m.material.dispose(); });
      gradientFieldMeshes.forEach(m => { scene.remove(m); m.geometry.dispose(); m.material.dispose(); });
      activatorMeshes = [];
      radiusFieldMeshes = [];
      gradientFieldMeshes = [];

      // Only create activator visuals for noise-preview tab (total-preview uses global noise)
      if (currentTab !== 'noise-preview') return;

      const showDebug = document.getElementById('showActivatorDebug')?.checked;
      const showRadius = document.getElementById('showRadiusField')?.checked;
      const showGradient = document.getElementById('showGradientField')?.checked;

      // Create gradient texture if needed
      if (showGradient && !gradientTexture) {
        gradientTexture = createGradientTexture();
      }

      for (let i = 0; i < params.activatorCount; i++) {
        // Activator sphere (small wireframe at center)
        if (showDebug) {
          const geometry = new THREE.SphereGeometry(15, 8, 8);
          const material = new THREE.MeshBasicMaterial({
            color: 0xd4a855,
            transparent: true,
            opacity: 0.9,
            wireframe: true
          });
          const mesh = new THREE.Mesh(geometry, material);
          scene.add(mesh);
          activatorMeshes.push(mesh);
        }

        // Radius ring (outline only)
        if (showRadius) {
          const ringGeometry = new THREE.RingGeometry(
            params.activationRadius - 3,
            params.activationRadius + 3,
            64
          );
          const ringMaterial = new THREE.MeshBasicMaterial({
            color: 0xd4a855,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
          });
          const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
          scene.add(ringMesh);
          radiusFieldMeshes.push(ringMesh);
        }

        // Gradient field (filled circle with gradient showing activation strength)
        if (showGradient) {
          const planeGeometry = new THREE.PlaneGeometry(
            params.activationRadius * 2,
            params.activationRadius * 2
          );
          const planeMaterial = new THREE.MeshBasicMaterial({
            map: gradientTexture,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false
          });
          const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
          scene.add(planeMesh);
          gradientFieldMeshes.push(planeMesh);
        }
      }
    }

    function updateActivatorVisuals() {
      const showDebug = document.getElementById('showActivatorDebug')?.checked;
      const showRadius = document.getElementById('showRadiusField')?.checked;
      const showGradient = document.getElementById('showGradientField')?.checked;

      for (let i = 0; i < activatorMeshes.length; i++) {
        if (i < params.activatorCount && showDebug) {
          activatorMeshes[i].visible = true;
          activatorMeshes[i].position.set(
            activatorPositions[i * 3],
            activatorPositions[i * 3 + 1],
            activatorPositions[i * 3 + 2]
          );
        } else if (activatorMeshes[i]) {
          activatorMeshes[i].visible = false;
        }
      }

      for (let i = 0; i < radiusFieldMeshes.length; i++) {
        if (i < params.activatorCount && showRadius) {
          radiusFieldMeshes[i].visible = true;
          radiusFieldMeshes[i].position.set(
            activatorPositions[i * 3],
            activatorPositions[i * 3 + 1],
            activatorPositions[i * 3 + 2]
          );
        } else if (radiusFieldMeshes[i]) {
          radiusFieldMeshes[i].visible = false;
        }
      }

      for (let i = 0; i < gradientFieldMeshes.length; i++) {
        if (i < params.activatorCount && showGradient) {
          gradientFieldMeshes[i].visible = true;
          gradientFieldMeshes[i].position.set(
            activatorPositions[i * 3],
            activatorPositions[i * 3 + 1],
            activatorPositions[i * 3 + 2]
          );
          // Scale based on activation radius
          const scale = params.activationRadius / 1000;
          gradientFieldMeshes[i].scale.setScalar(scale);
        } else if (gradientFieldMeshes[i]) {
          gradientFieldMeshes[i].visible = false;
        }
      }
    }

    // Particles and connection lines
    let particles;
    let connectionLines = [];
    let nodeWorldPositions = {}; // Store node positions for connections

    function regenerateParticles() {
      // Clean up old particles
      if (particles) {
        scene.remove(particles);
        particles.geometry.dispose();
        particles.material.dispose();
        particles = null;
      }

      // Clean up old connection lines
      connectionLines.forEach(line => {
        scene.remove(line);
        if (line.geometry) line.geometry.dispose();
        if (line.material) line.material.dispose();
      });
      connectionLines = [];
      nodeWorldPositions = {};

      // Get the current pattern from dropdown
      const patternKey = document.getElementById('patternSelect')?.value || 'factory';
      const pattern = customPatterns[patternKey] || patternDefinitions[patternKey];

      if (!pattern) {
        console.error('No pattern found:', patternKey);
        return;
      }

      // Use umlNodes if available (edited positions), otherwise use pattern nodes with layout
      let nodes;
      if (umlNodes.length > 0 && umlNodes[0].id) {
        nodes = JSON.parse(JSON.stringify(umlNodes));
      } else {
        nodes = JSON.parse(JSON.stringify(pattern.nodes));
        // Apply current layout
        const layoutData = pattern.layouts?.[currentLayout];
        if (layoutData) {
          layoutData.forEach(saved => {
            const node = nodes.find(n => n.id === saved.id);
            if (node) {
              node.x = saved.x;
              node.y = saved.y;
            }
          });
        }
      }

      // Store in currentPattern
      const xs = nodes.map(n => n.x || 0);
      const ys = nodes.map(n => n.y || 0);
      currentPattern = {
        nodes: nodes,
        connections: pattern.connections || [],
        minX: Math.min(...xs),
        maxX: Math.max(...xs),
        minY: Math.min(...ys),
        maxY: Math.max(...ys)
      };

      const isNoiseTab = currentTab === 'noise-generator';

      if (isNoiseTab) {
        // Noise tab: single node particle view
        particles = createParticleSystem(true);
        scene.add(particles);
        camera.position.set(0, 0, 500);
      } else {
        // Preview tab: full UML as particles with connections
        particles = createParticleSystem(false);
        scene.add(particles);

        // Add curved connection lines
        createCurvedConnections();

        // Adjust camera based on pattern extent
        const gridSpacing = 18;
        const extentX = (currentPattern.maxX - currentPattern.minX) * gridSpacing;
        const extentY = (currentPattern.maxY - currentPattern.minY) * gridSpacing;
        const maxExtent = Math.max(extentX, extentY, 400);
        camera.position.set(0, 0, maxExtent * 3);
      }

      createActivatorVisuals();
      controls.target.set(0, 0, 0);
      controls.update();
    }

    // Create curved connection lines between nodes (using stored positions from particle creation)
    function createCurvedConnections() {
      if (!currentPattern || !currentPattern.connections) return;

      currentPattern.connections.forEach(conn => {
        const from = nodeWorldPositions[conn.from];
        const to = nodeWorldPositions[conn.to];
        if (!from || !to) return;

        // Calculate edge connection points
        let startX, startY, endX, endY;
        const dx = to.x - from.x;
        const dy = to.y - from.y;

        // Connect to sides based on relative position
        if (Math.abs(dy) > Math.abs(dx) * 0.5) {
          // More vertical - connect top/bottom
          if (dy > 0) {
            startX = from.x;
            startY = from.top;
            endX = to.x;
            endY = to.bottom;
          } else {
            startX = from.x;
            startY = from.bottom;
            endX = to.x;
            endY = to.top;
          }
        } else {
          // More horizontal - connect left/right
          if (dx > 0) {
            startX = from.right;
            startY = from.y;
            endX = to.left;
            endY = to.y;
          } else {
            startX = from.left;
            startY = from.y;
            endX = to.right;
            endY = to.y;
          }
        }

        // Create curved bezier line
        const midX = (startX + endX) / 2;
        const midY = (startY + endY) / 2;

        let curve;
        if (Math.abs(startY - endY) > Math.abs(startX - endX)) {
          // Vertical curve
          curve = new THREE.QuadraticBezierCurve3(
            new THREE.Vector3(startX, startY, 0),
            new THREE.Vector3(startX, midY, 0),
            new THREE.Vector3(endX, endY, 0)
          );
        } else {
          // Horizontal curve
          curve = new THREE.QuadraticBezierCurve3(
            new THREE.Vector3(startX, startY, 0),
            new THREE.Vector3(midX, startY, 0),
            new THREE.Vector3(endX, endY, 0)
          );
        }

        const points = curve.getPoints(30);
        const geometry = new THREE.BufferGeometry().setFromPoints(points);

        const isDashed = conn.type === 'implements' || conn.type === 'dependency';
        let material;
        if (isDashed) {
          material = new THREE.LineDashedMaterial({
            color: 0xd4a855,
            dashSize: 3,
            gapSize: 2,
            opacity: 0.8,
            transparent: true
          });
        } else {
          material = new THREE.LineBasicMaterial({
            color: 0xd4a855,
            opacity: 0.8,
            transparent: true
          });
        }

        const line = new THREE.Line(geometry, material);
        if (isDashed) line.computeLineDistances();

        scene.add(line);
        connectionLines.push(line);

        // Add arrowhead at the end
        const lastPoint = points[points.length - 1];
        const prevPoint = points[points.length - 2];
        const angle = Math.atan2(lastPoint.y - prevPoint.y, lastPoint.x - prevPoint.x);
        const size = 5;

        if (conn.type === 'aggregation' || conn.type === 'composition') {
          // Diamond
          const diamondPoints = [];
          const cx = lastPoint.x - Math.cos(angle) * size;
          const cy = lastPoint.y - Math.sin(angle) * size;
          for (let i = 0; i < 4; i++) {
            const a = angle + Math.PI/2 + (i * Math.PI / 2);
            diamondPoints.push(new THREE.Vector3(cx + Math.cos(a) * size * 0.5, cy + Math.sin(a) * size * 0.5, 0));
          }
          diamondPoints.push(diamondPoints[0].clone());
          const dGeom = new THREE.BufferGeometry().setFromPoints(diamondPoints);
          const diamond = new THREE.Line(dGeom, new THREE.LineBasicMaterial({ color: 0xd4a855 }));
          scene.add(diamond);
          connectionLines.push(diamond);
        } else {
          // Triangle arrow
          const p1 = lastPoint.clone();
          const p2 = new THREE.Vector3(lastPoint.x - size * Math.cos(angle - Math.PI/7), lastPoint.y - size * Math.sin(angle - Math.PI/7), 0);
          const p3 = new THREE.Vector3(lastPoint.x - size * Math.cos(angle + Math.PI/7), lastPoint.y - size * Math.sin(angle + Math.PI/7), 0);
          const aGeom = new THREE.BufferGeometry().setFromPoints([p1, p2, p3, p1]);
          const arrow = new THREE.Line(aGeom, new THREE.LineBasicMaterial({ color: 0xd4a855 }));
          scene.add(arrow);
          connectionLines.push(arrow);
        }
      });
    }

    // Noise preview
    const noisePreview = document.getElementById('noise-preview');
    const noiseCtx = noisePreview.getContext('2d');
    const previewSize = 64;
    noisePreview.width = previewSize;
    noisePreview.height = previewSize;

    let previewTime = 0;
    let lastPreviewUpdate = 0;

    function simpleNoise2D(x, y) {
      const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
      return (n - Math.floor(n)) * 2 - 1;
    }

    function perlinNoise(x, y, z) {
      const X = Math.floor(x) & 255;
      const Y = Math.floor(y) & 255;
      x -= Math.floor(x);
      y -= Math.floor(y);
      const u = x * x * (3 - 2 * x);
      const v = y * y * (3 - 2 * y);
      const a = simpleNoise2D(X, Y + z * 100);
      const b = simpleNoise2D(X + 1, Y + z * 100);
      const c = simpleNoise2D(X, Y + 1 + z * 100);
      const d = simpleNoise2D(X + 1, Y + 1 + z * 100);
      const lerp = (t, a, b) => a + t * (b - a);
      return lerp(v, lerp(u, a, b), lerp(u, c, d));
    }

    function updateNoisePreview() {
      const imageData = noiseCtx.createImageData(previewSize, previewSize);
      for (let y = 0; y < previewSize; y++) {
        for (let x = 0; x < previewSize; x++) {
          const nx = (x / previewSize - 0.5) * 4 * params.noiseScale * 100;
          const ny = (y / previewSize - 0.5) * 4 * params.noiseScale * 100;
          let noise = perlinNoise(nx, ny, previewTime * params.noiseSpeed);
          noise = Math.sign(noise) * Math.pow(Math.abs(noise), 1 / params.sharpness);
          noise = Math.max(-1, Math.min(1, noise * params.contrast));
          const brightness = Math.floor((noise * 0.5 + 0.5) * 255);
          const i = (y * previewSize + x) * 4;
          imageData.data[i] = brightness;
          imageData.data[i + 1] = brightness;
          imageData.data[i + 2] = brightness;
          imageData.data[i + 3] = 255;
        }
      }
      noiseCtx.putImageData(imageData, 0, 0);
    }

    // Tab switching
    function switchTab(tabId) {
      currentTab = tabId;

      // Update data attribute for CSS visibility rules
      rendererContainer.dataset.currentTab = tabId;

      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

      document.querySelector(`.tab[data-tab="${tabId}"]`).classList.add('active');
      document.getElementById(`tab-${tabId}`).classList.add('active');

      // Clear selection when switching tabs
      selectedNodeId = null;

      // Only regenerate particles for noise/preview tabs
      if (tabId !== 'uml-generator') {
        regenerateParticles();
      } else {
        // Update UML editor when switching to UML tab
        if (currentPattern) {
          updateUmlFromPattern();
        }
      }
    }

    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => switchTab(tab.dataset.tab));
    });

    // Apply loaded params to UI
    function applyParamsToUI() {
      // Standard single-value controls
      const controlIds = [
        'density', 'particleSize', 'particleOpacity', 'noiseScale', 'blockSize',
        'sharpness', 'contrast', 'turbulence', 'lacunarity', 'persistence',
        'noiseSpeed', 'displacementXY', 'displacementZ', 'activatorCount',
        'activationRadius', 'activatorSpeed', 'falloff',
        // Camera path (Lissajous) controls
        'cameraSpeed', 'cameraAmpX', 'cameraAmpY', 'cameraAmpZ',
        'cameraFreqX', 'cameraFreqY', 'cameraFreqZ',
        // Camera lens controls
        'cameraDistance', 'cameraFov', 'cameraTilt',
        // Film grain controls
        'filmGrain', 'grainRoughness', 'grainSize',
        // Glitch effect controls
        'glitchIntensity', 'glitchChance', 'glitchMaskScale', 'glitchSpeed', 'rgbSplit',
        // Post effect controls
        'vignette',
      ];

      controlIds.forEach(id => {
        const el = document.getElementById(id);
        if (el && params[id] !== undefined) {
          el.value = params[id];
          const valEl = document.getElementById(id + 'Val');
          if (valEl) {
            const v = params[id];
            valEl.textContent = Number.isInteger(v) ? v : v.toFixed(2).replace(/\.?0+$/, '');
          }
        }
      });

      // Noise type
      const noiseTypeEl = document.getElementById('noiseType');
      if (noiseTypeEl && params.noiseType) {
        noiseTypeEl.value = params.noiseType;
      }

      // Pattern selector
      const patternEl = document.getElementById('patternSelect');
      if (patternEl && params.selectedPattern) {
        patternEl.value = params.selectedPattern;
      }

      // Cinematic mode toggle
      const cinematicModeEl = document.getElementById('cinematicMode');
      if (cinematicModeEl && params.cinematicMode !== undefined) {
        cinematicModeEl.checked = params.cinematicMode;
      }

    }

    // UI Controls setup
    function setupControls() {
      // Standard single-value controls
      const controlIds = [
        'density', 'particleSize', 'particleOpacity', 'noiseScale', 'blockSize',
        'sharpness', 'contrast', 'turbulence', 'lacunarity', 'persistence',
        'noiseSpeed', 'displacementXY', 'displacementZ', 'activatorCount',
        'activationRadius', 'activatorSpeed', 'falloff',
        // Camera path (Lissajous) controls
        'cameraSpeed', 'cameraAmpX', 'cameraAmpY', 'cameraAmpZ',
        'cameraFreqX', 'cameraFreqY', 'cameraFreqZ',
        // Camera lens controls
        'cameraDistance', 'cameraTilt',
        // Film grain controls
        'filmGrain', 'grainRoughness', 'grainSize',
        // Glitch effect controls
        'glitchIntensity', 'glitchChance', 'glitchMaskScale', 'glitchSpeed', 'rgbSplit',
        // Post effect controls
        'vignette',
      ];

      controlIds.forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;

        el.addEventListener('input', (e) => {
          const value = parseFloat(e.target.value);
          params[id] = value;

          const valEl = document.getElementById(id + 'Val');
          if (valEl) {
            valEl.textContent = Number.isInteger(value) ? value : value.toFixed(2).replace(/\.?0+$/, '');
          }

          if (particles && particles.material.uniforms[id]) {
            particles.material.uniforms[id].value = value;
          }

          if (id === 'activatorCount' || id === 'activationRadius') {
            createActivatorVisuals();
          }

          // Regenerate camera path when relevant parameters change
          const cameraPathParams = ['cameraAmpX', 'cameraAmpY', 'cameraAmpZ', 'cameraFreqX', 'cameraFreqY', 'cameraFreqZ', 'cameraDistance', 'cameraTilt'];
          if (cameraPathParams.includes(id)) {
            createCinematicCameraVisual();
          }

          autoSave();
        });
      });

      document.getElementById('noiseType').addEventListener('change', (e) => {
        params.noiseType = e.target.value;
        const typeMap = { 'smooth': 0, 'square': 1, 'ridged': 2, 'cellular': 3 };
        if (particles) {
          particles.material.uniforms.noiseType.value = typeMap[params.noiseType];
        }
        autoSave();
      });

      // Camera FOV control (needs special handling for projection matrix)
      document.getElementById('cameraFov')?.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        params.cameraFov = value;
        const valEl = document.getElementById('cameraFovVal');
        if (valEl) valEl.textContent = value.toFixed(0);
        if (camera) {
          camera.fov = value;
          camera.updateProjectionMatrix();
        }
        autoSave();
      });

      // Cinematic mode toggle
      document.getElementById('cinematicMode')?.addEventListener('change', (e) => {
        params.cinematicMode = e.target.checked;
        autoSave();
      });

      // Tab-specific buttons
      document.getElementById('generateUML')?.addEventListener('click', () => {
        // Generate pattern and update UML editor
        generatePattern();
        updateUmlFromPattern();
        // Switch to preview tab
        switchTab('total-preview');
      });

      document.getElementById('regenerateNoise')?.addEventListener('click', regenerateParticles);
      document.getElementById('regeneratePreview')?.addEventListener('click', regenerateParticles);

      // Save buttons - save to values.json on disk
      document.getElementById('saveNoiseSettings')?.addEventListener('click', () => {
        saveSettingsToFile();
      });

      document.getElementById('saveAllSettings')?.addEventListener('click', () => {
        saveSettingsToFile();
      });

      // Debug toggles
      document.getElementById('showActivatorDebug')?.addEventListener('change', createActivatorVisuals);
      document.getElementById('showRadiusField')?.addEventListener('change', createActivatorVisuals);
      document.getElementById('showGradientField')?.addEventListener('change', createActivatorVisuals);

      // Pattern selector
      document.getElementById('patternSelect')?.addEventListener('change', (e) => {
        params.selectedPattern = e.target.value;

        // Reset to layout 1 when switching patterns
        currentLayout = '1';
        document.querySelectorAll('.layout-btn').forEach(btn => btn.classList.remove('active'));
        document.querySelector('.layout-btn[data-layout="1"]')?.classList.add('active');

        generatePattern();
        updateUmlFromPattern();

        // Load layout 1 if it exists
        loadLayout('1');

        autoSave();
      });

      // Pattern management buttons
      document.getElementById('newPatternBtn')?.addEventListener('click', () => {
        openModal('newPatternModal');
      });

      document.getElementById('deletePatternBtn')?.addEventListener('click', () => {
        showDeletePatternModal();
      });


      // Close modals on escape key, Enter to submit new pattern
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          closeModal('newPatternModal');
          closeModal('deletePatternModal');
        }
      });

      document.getElementById('newPatternName')?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          createNewPattern();
        }
      });

      // Close modals on overlay click
      document.querySelectorAll('.modal-overlay').forEach(modal => {
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            modal.classList.remove('visible');
          }
        });
      });


      // Apply loaded params to UI
      applyParamsToUI();

      // Initialize pattern description
      const patternKey = params.selectedPattern || 'factory';
      const pattern = customPatterns[patternKey] || patternDefinitions[patternKey];
      if (pattern) {
        updatePatternDescription(pattern.description);
      }
    }

    // Animation loop
    let lastTime = performance.now();
    let frameCount = 0;

    // Camera animation time
    let cameraTime = 0;

    // Film overlay canvas context
    let filmCtx = null;
    let filmCanvas = null;

    function initFilmOverlay() {
      filmCanvas = document.getElementById('film-overlay');
      if (filmCanvas) {
        filmCtx = filmCanvas.getContext('2d');
        resizeFilmOverlay();
      }
    }

    function resizeFilmOverlay() {
      if (filmCanvas) {
        filmCanvas.width = window.innerWidth - sidebarWidth;
        filmCanvas.height = window.innerHeight;
      }
    }

    function renderFilmEffects() {
      if (!filmCtx || !filmCanvas || currentTab !== 'total-preview') return;

      const w = filmCanvas.width;
      const h = filmCanvas.height;

      // Clear
      filmCtx.clearRect(0, 0, w, h);

      // Simple film grain only
      if (params.filmGrain > 0) {
        const imageData = filmCtx.createImageData(w, h);
        const data = imageData.data;
        const grain = params.filmGrain * 255;

        for (let i = 0; i < data.length; i += 4) {
          const noise = (Math.random() - 0.5) * grain;
          data[i] = 128 + noise;
          data[i + 1] = 128 + noise;
          data[i + 2] = 128 + noise;
          data[i + 3] = Math.abs(noise) * 0.5;
        }
        filmCtx.putImageData(imageData, 0, 0);
      }

      // Vignette
      if (params.vignette > 0) {
        const gradient = filmCtx.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w, h) * 0.7);
        gradient.addColorStop(0, 'rgba(0,0,0,0)');
        gradient.addColorStop(0.5, 'rgba(0,0,0,0)');
        gradient.addColorStop(1, `rgba(0,0,0,${params.vignette})`);
        filmCtx.fillStyle = gradient;
        filmCtx.fillRect(0, 0, w, h);
      }
    }

    // Cinematic camera visual (shown when not in POV mode)
    let cinematicCameraVisual = null;
    let cinematicCameraPath = null;
    let globalCamera = null; // The camera we actually render from

    function createCinematicCameraVisual() {
      // Safety check - don't create if scene isn't ready
      if (!scene || !params.cameraDistance) return;

      if (cinematicCameraVisual) {
        scene.remove(cinematicCameraVisual);
        cinematicCameraVisual.geometry?.dispose();
        cinematicCameraVisual.material?.dispose();
      }
      if (cinematicCameraPath) {
        scene.remove(cinematicCameraPath);
        cinematicCameraPath.geometry?.dispose();
        cinematicCameraPath.material?.dispose();
      }

      // Camera frustum visual
      const cameraGeo = new THREE.ConeGeometry(15, 30, 4);
      cameraGeo.rotateX(Math.PI / 2);
      const cameraMat = new THREE.MeshBasicMaterial({
        color: 0xd4a855,
        wireframe: true,
        transparent: true,
        opacity: 0.8
      });
      cinematicCameraVisual = new THREE.Mesh(cameraGeo, cameraMat);
      cinematicCameraVisual.visible = !params.cinematicMode;
      scene.add(cinematicCameraVisual);

      // Draw the Lissajous path
      const pathPoints = [];
      const segments = 200;
      for (let i = 0; i <= segments; i++) {
        const t = (i / segments) * Math.PI * 4;
        const baseDistance = params.cameraDistance;
        const tiltRad = params.cameraTilt * Math.PI / 180;

        const x = params.cameraAmpX * Math.sin(params.cameraFreqX * t);
        const y = params.cameraAmpY * Math.sin(params.cameraFreqY * t + Math.PI / 4);
        const z = baseDistance + params.cameraAmpZ * Math.sin(params.cameraFreqZ * t + Math.PI / 2);

        const tiltedY = y * Math.cos(tiltRad) - z * Math.sin(tiltRad) * 0.3;
        const tiltedZ = y * Math.sin(tiltRad) * 0.1 + z * Math.cos(tiltRad);

        pathPoints.push(new THREE.Vector3(x, tiltedY, tiltedZ));
      }

      const pathGeo = new THREE.BufferGeometry().setFromPoints(pathPoints);
      const pathMat = new THREE.LineBasicMaterial({
        color: 0xd4a855,
        transparent: true,
        opacity: 0.3
      });
      cinematicCameraPath = new THREE.Line(pathGeo, pathMat);
      cinematicCameraPath.visible = !params.cinematicMode;
      scene.add(cinematicCameraPath);
    }

    function getCinematicPosition(time) {
      const baseDistance = params.cameraDistance;
      const tiltRad = params.cameraTilt * Math.PI / 180;

      const x = params.cameraAmpX * Math.sin(params.cameraFreqX * time);
      const y = params.cameraAmpY * Math.sin(params.cameraFreqY * time + Math.PI / 4);
      const z = baseDistance + params.cameraAmpZ * Math.sin(params.cameraFreqZ * time + Math.PI / 2);

      const tiltedY = y * Math.cos(tiltRad) - z * Math.sin(tiltRad) * 0.3;
      const tiltedZ = y * Math.sin(tiltRad) * 0.1 + z * Math.cos(tiltRad);

      return { x, y: tiltedY, z: tiltedZ };
    }

    function updateCameraMode() {
      if (!camera) return;

      if (cinematicCameraVisual) {
        cinematicCameraVisual.visible = !params.cinematicMode;
      }
      if (cinematicCameraPath) {
        cinematicCameraPath.visible = !params.cinematicMode;
      }

      if (!params.cinematicMode) {
        // Switch to global view - position camera further back
        camera.position.set(0, 400, 1500);
        camera.lookAt(0, 0, 0);
        camera.fov = 60;
        camera.updateProjectionMatrix();
      } else {
        // Switch to cinematic POV
        camera.fov = params.cameraFov || 50;
        camera.updateProjectionMatrix();
      }
    }

    function updateCinematicCamera(delta) {
      if (!params.cinematicMode || currentTab !== 'total-preview') return;

      cameraTime += delta * params.cameraSpeed;

      const pos = getCinematicPosition(cameraTime);

      if (params.cinematicMode) {
        // POV mode - camera follows the path
        camera.position.set(pos.x, pos.y, pos.z);
        camera.lookAt(0, 0, 0);

        // Update FOV if changed
        if (camera.fov !== params.cameraFov) {
          camera.fov = params.cameraFov;
          camera.updateProjectionMatrix();
        }
      } else {
        // Global view - update camera visual position
        if (cinematicCameraVisual) {
          cinematicCameraVisual.position.set(pos.x, pos.y, pos.z);
          cinematicCameraVisual.lookAt(0, 0, 0);
        }
      }
    }

    function animate() {
      requestAnimationFrame(animate);

      const now = performance.now();
      const delta = (now - lastTime) / 1000;
      frameCount++;

      if (now - lastPreviewUpdate > 100) {
        previewTime += 0.1;
        updateNoisePreview();
        lastPreviewUpdate = now;
      }

      if (frameCount % 60 === 0) {
        const fpsEl = document.getElementById('previewFps');
        if (fpsEl) fpsEl.textContent = `${Math.round(1 / delta)} fps`;
      }

      // Update cinematic camera for preview tab
      if (currentTab === 'total-preview') {
        updateCinematicCamera(delta);
        renderFilmEffects();
      }

      // Update shader uniforms
      if (particles) {
        particles.material.uniforms.time.value += delta;
      }

      lastTime = now;
      if (currentTab !== 'total-preview' || !params.cinematicMode) {
        controls.update();
      }
      renderer.render(scene, camera);
    }

    // Initialize application
    async function init() {
      // Load settings from values.json
      await loadSettingsFromFile();

      // Load patterns from JSON files
      await loadCustomPatterns();

      // Ensure dropdown has patterns (fallback if server not running)
      if (Object.keys(customPatterns).length === 0) {
        updatePatternDropdown();
      }

      // Initialize activators with loaded params
      initActivators();

      // Setup UI controls and apply loaded values
      setupControls();

      // Initialize film overlay
      initFilmOverlay();

      // Initialize cinematic camera visual
      createCinematicCameraVisual();

      // Generate initial pattern and update UML editor
      generatePattern();
      updateUmlFromPattern();

      // Layout variation buttons
      document.querySelectorAll('.layout-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          switchLayout(btn.dataset.layout);
        });
      });

      // Position input handlers
      document.getElementById('nodePositionX').addEventListener('change', (e) => {
        updateNodePosition('x', e.target.value);
      });
      document.getElementById('nodePositionY').addEventListener('change', (e) => {
        updateNodePosition('y', e.target.value);
      });

      // Initialize viewBox and zoom display
      updateViewBox();
      updateZoomDisplay();

      // Mark as initialized - enables auto-save
      isInitialized = true;

      // Start animation loop
      animate();
    }

    // Start the application
    init();

    // Handle resize
    window.addEventListener('resize', () => {
      const width = window.innerWidth - sidebarWidth;
      camera.aspect = width / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(width, window.innerHeight);
      resizeFilmOverlay();
      if (particles) {
        particles.material.uniforms.pixelRatio.value = renderer.getPixelRatio();
      }
    });
  </script>
</body>
</html>
